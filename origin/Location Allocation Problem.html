
<!-- saved from url=(0066)http://www.csie.ntnu.edu.tw/~u91029/LocationAllocationProblem.html -->
<html lang="zh-TW"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="./Location Allocation Problem_files/style.css">
<title>演算法筆記 - Location Allocation Problem</title></head><body>
<div class="a" id="1"><div class="h">
<p class="b">Location Allocation Problem</p>
</div><div class="c">
<p class="t">Location Allocation Problem （ Facility Location Problem ）</p>
<p>給定許多個地點，設立 p 個聯絡站，使得每一個地點皆可被其中一間聯絡站聯絡到，而且越有效率越好。</p>
<img src="./Location Allocation Problem_files/LocationAllocationProblem1.png">
<p>深入地定義「效率」的意義，得以細分許多問題：令聯絡站離各地點的距離總和最小（ p-Median Problem ）。令聯絡站離各地點的距離最大值最小（ p-Center Problem ）。在各地設立聯絡站需要成本，但建立聯絡站後會從周遭地點獲得利益，令設立聯絡站後利益最大（ Uncapacitated Facility Location Problem ）。令各地點離聯絡站的中繼點不超過一定數量（ Range Assignment Problem ）。</p>
<p>這些問題在現實生活中的應用，例如超商的物流通路、有線電視的纜線鋪設、基地台的設立位置等等。可惜這些問題已經被證明是 NP-hard 問題，無法快速得到精準解答。</p>
<p>以下只討論一維版本。所有的地點和連絡站都在數線上。</p>

</div></div><div class="a" id="2"><div class="h">
<p class="b">p-Median Problem</p>
</div><div class="c">
<p class="t">p-Median Problem</p>
<p>給定許多個地點，設立 p 個聯絡站，使得每一個地點皆可被其中一間聯絡站聯絡到。令聯絡距離的總和最小。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem1.png">
<p>此處討論一維版本，地點和連絡站落於數線上。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem2.png">
<p class="t">簡化問題、觀察問題：只有一個連絡站</p>
<p>將聯絡站放在中位數是最好的。如果中位數是在兩個位置中間的話，則聯絡站可以游移於兩個位置之間、其上，都不會改變聯絡距離的總和。所有的聯絡站都可以挪至地點之上！</p>
<img src="./Location Allocation Problem_files/p-MedianProblem3.png">
<p>證明不難。試著移動聯絡站，讓各個地點的聯絡距離此消彼長，觀察一下就會明白了。動手試試看吧！</p>
<p>另外也得到一個重要的結論：所有的聯絡站都可以挪至地點之上，而不會改變聯絡距離的總和。</p>
<p class="t">簡化問題、觀察問題：只有一個地點</p>
<p>將全部的聯絡站放在該地點上是最好的。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem4.png">
<p>聯絡站全部疊在一起，有摩肩接踵、水洩不通的感覺，理當好好分配才對。說到分配，如果聯絡站數量大於等於地點數量，只要將聯絡站安排在各個地點上，聯絡距離的總和就是零了。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem5.png">
<p class="t">簡化問題、觀察問題：地緣</p>
<p>為了拉近聯絡距離，所有地點都會連向最近的聯絡站，而不會有捨近求遠的情形。換個角度來看，一個聯絡站只會連向鄰近的地點，而不會有捨近求遠的情形。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem6.png">
<p>p-Median Problem 可以重新想成：依照地緣，所有地點分配成 p 個區域，每一區自行設立一個聯絡站，位於中位數，可挪至鄰近地點。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem7.png">
<p>至此， p-Median Problem 就成了如何分區的問題。</p>
<p class="t">簡化問題、觀察問題：分區</p>
<p>如果有地點選擇聯絡站時捨近求遠，表示這種分區方式不好。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem8.png">
<p>各個區域之間相鄰越遠越好？大家自行觀察看看吧。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem9.png">
<p class="t">動態規劃</p>
<p>聯絡距離的總和，可以以區為單位，分別計算，最後再統計 —— 這就是在分割問題。</p>
<p>拿掉最邊邊的一區、拿掉該區的聯絡站，如此便縮小了問題範疇，讓小問題與原問題類似。接著窮舉該區的各種大小，求得遞迴式。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem10.png">
<p>注意別讓剩下來的地點太少、剩下的聯絡站太多，而導致連絡站重疊。妥善分配重疊的聯絡站，一定能使聯絡距離的總和更小。沒有必要枚舉出讓聯絡站重疊的分區方式。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem11.png">
<pre>f(p, n) = 
 { min( f(p-1, p-1) + d(p  , n) ,
 {      f(p-1, p  ) + d(p+1, n) ,
 {      ...                     ,
 {      f(p-1, n-2) + d(n-1, n) ,
 {      f(p-1, n-1) + d(n  , n) )  if p &lt; n  &amp;&amp; n &gt;= 0
 {
 { 0                               if p &gt;= n &amp;&amp; n &gt;= 0
 { +inf                            otherwise

p：已設立了p個聯絡站。
n：已涵蓋了第1個到第n個地點。
f(p, n)：設立p個聯絡站，涵蓋第1個到第n個地點時，其聯絡距離的總和。
d(i, j)：第i個地點到第j個地點所構成的區域，其聯絡距離的總和最小值。
         可利用中位數算得。
</pre>
<p>N 為地點個數， P 為聯絡站個數。總共 O(NP) 個子問題，計算一個子問題需時 O(N) ，時間複雜度為 O(N²P) 。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem12.png">
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">P</span><span>&nbsp;=&nbsp;</span><span class="value">3</span><span>,&nbsp;</span><span class="word">N</span><span>&nbsp;=&nbsp;</span><span class="value">6</span><span>;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;P為聯絡站個數，N為地點個數。</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;為了方便實作，數字右移一格。</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">location</span><span>[</span><span class="value">6</span><span>+</span><span class="value">1</span><span>]&nbsp;=&nbsp;{</span><span class="value">0</span><span>,&nbsp;</span><span class="value">2</span><span>,&nbsp;</span><span class="value">6</span><span>,&nbsp;</span><span class="value">11</span><span>,&nbsp;</span><span class="value">14</span><span>,&nbsp;</span><span class="value">18</span><span>,&nbsp;</span><span class="value">26</span><span>};&nbsp;&nbsp;</span><span class="comment">//&nbsp;需要排序</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">d</span><span>[</span><span class="value">6</span><span>+</span><span class="value">1</span><span>][</span><span class="value">6</span><span>+</span><span class="value">1</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;各種區域，其聯絡距離的總和。</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">f</span><span>[</span><span class="value">3</span><span>+</span><span class="value">1</span><span>][</span><span class="value">6</span><span>+</span><span class="value">1</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;DP表格</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">r</span><span>[</span><span class="value">3</span><span>+</span><span class="value">1</span><span>][</span><span class="value">6</span><span>+</span><span class="value">1</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;記錄最佳的分界線位置。</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">p_Median</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;Preprocessing。計算各種區域，其聯絡距離的總和。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">1</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;=</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="word">i</span><span>;&nbsp;</span><span class="word">j</span><span>&lt;=</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">m</span><span>&nbsp;=&nbsp;(</span><span class="word">i</span><span>+</span><span class="word">j</span><span>)/</span><span class="value">2</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;聯絡站位於中位數</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">d</span><span>[</span><span class="word">i</span><span>][</span><span class="word">j</span><span>]&nbsp;=&nbsp;</span><span class="value">0</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;聯絡距離的總和</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">k</span><span>=</span><span class="word">i</span><span>;&nbsp;</span><span class="word">k</span><span>&lt;=</span><span class="word">j</span><span>;&nbsp;++</span><span class="word">k</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">d</span><span>[</span><span class="word">i</span><span>][</span><span class="word">j</span><span>]&nbsp;+=&nbsp;</span><span class="word">abs</span><span>(</span><span class="word">location</span><span>[</span><span class="word">k</span><span>]&nbsp;-&nbsp;</span><span class="word">location</span><span>[</span><span class="word">m</span><span>]);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;Dynamic&nbsp;Programming。求出聯絡距離的總和最小值。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">memset</span><span>(</span><span class="word">f</span><span>,&nbsp;</span><span class="value">0</span><span>,&nbsp;</span><span class="keyword">sizeof</span><span>(</span><span class="word">f</span><span>));&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;f[0][...]&nbsp;=&nbsp;0;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">p</span><span>=</span><span class="value">1</span><span>;&nbsp;</span><span class="word">p</span><span>&lt;=</span><span class="word">P</span><span>;&nbsp;++</span><span class="word">p</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>=</span><span class="value">1</span><span>;&nbsp;</span><span class="word">n</span><span>&lt;=</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">n</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;計算子問題f(p,&nbsp;n)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">f</span><span>[</span><span class="word">p</span><span>][</span><span class="word">n</span><span>]&nbsp;=&nbsp;</span><span class="value">1e9</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">k</span><span>=</span><span class="word">p</span><span>;&nbsp;</span><span class="word">k</span><span>&lt;=</span><span class="word">n</span><span>;&nbsp;++</span><span class="word">k</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">f</span><span>[</span><span class="word">p</span><span>-</span><span class="value">1</span><span>][</span><span class="word">k</span><span>-</span><span class="value">1</span><span>]&nbsp;+&nbsp;</span><span class="word">d</span><span>[</span><span class="word">k</span><span>][</span><span class="word">n</span><span>]&nbsp;&lt;&nbsp;</span><span class="word">f</span><span>[</span><span class="word">p</span><span>][</span><span class="word">n</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">f</span><span>[</span><span class="word">p</span><span>][</span><span class="word">n</span><span>]&nbsp;=&nbsp;</span><span class="word">f</span><span>[</span><span class="word">p</span><span>-</span><span class="value">1</span><span>][</span><span class="word">k</span><span>-</span><span class="value">1</span><span>]&nbsp;+&nbsp;</span><span class="word">d</span><span>[</span><span class="word">k</span><span>][</span><span class="word">n</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">r</span><span>[</span><span class="word">p</span><span>][</span><span class="word">n</span><span>]&nbsp;=&nbsp;</span><span class="word">k</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;從第k個位置往右到第j個位置</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;都屬於這個區域</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="string">"聯絡距離的總和最小值是"</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="word">f</span><span>[</span><span class="word">P</span><span>][</span><span class="word">N</span><span>];</span></li><li><span>}</span></li></ol></div>
<p class="t">動態規劃： Monotonicity</p>
<p>不難發現，分界線位於最適中、最均衡的位置，讓聯絡距離的總和最小。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem13.png">
<p>觀察地點逐步增加的問題們。最佳分界線漸漸右移。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem14.png">
<p>觀察聯絡站逐步增加的問題們。最佳分界線漸漸右移。</p>
<img src="./Location Allocation Problem_files/p-MedianProblem15.png">
<p>因此我們不必窮舉所有的區域大小！但是時間複雜度仍然是 O(N²P) 。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span>&nbsp;&nbsp;&nbsp;&nbsp;......</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">memset</span><span>(</span><span class="word">f</span><span>,&nbsp;</span><span class="value">0</span><span>,&nbsp;</span><span class="keyword">sizeof</span><span>(</span><span class="word">f</span><span>));</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">memset</span><span>(</span><span class="word">r</span><span>,&nbsp;</span><span class="value">0</span><span>,&nbsp;</span><span class="keyword">sizeof</span><span>(</span><span class="word">r</span><span>));&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;初始化為零</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;......</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">f</span><span>[</span><span class="word">p</span><span>][</span><span class="word">n</span><span>]&nbsp;=&nbsp;</span><span class="value">1e9</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">kk</span><span>&nbsp;=&nbsp;</span><span class="word">max</span><span>(</span><span class="word">i</span><span>,&nbsp;</span><span class="word">r</span><span>[</span><span class="word">p</span><span>][</span><span class="word">n</span><span>-</span><span class="value">1</span><span>],&nbsp;</span><span class="word">r</span><span>[</span><span class="word">p</span><span>-</span><span class="value">1</span><span>][</span><span class="word">n</span><span>]);&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">k</span><span>=</span><span class="word">kk</span><span>;&nbsp;</span><span class="word">k</span><span>&lt;=</span><span class="word">n</span><span>;&nbsp;++</span><span class="word">k</span><span>)&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;加速</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">f</span><span>[</span><span class="word">p</span><span>-</span><span class="value">1</span><span>][</span><span class="word">k</span><span>-</span><span class="value">1</span><span>]&nbsp;+&nbsp;</span><span class="word">d</span><span>[</span><span class="word">k</span><span>][</span><span class="word">n</span><span>]&nbsp;&lt;&nbsp;</span><span class="word">f</span><span>[</span><span class="word">p</span><span>][</span><span class="word">n</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/6/662.html">662</a></p>
<p class="t">動態規劃： Convex Hull</p>
<p>採用凸包優化，斜率皆是 1 ，可視作 deque 優化，時間複雜度是 O(NP) 。</p>

</div></div><div class="a" id="3"><div class="h">
<p class="b">p-Center Problem</p>
</div><div class="c">
<p class="t">p-Center Problem</p>
<p>給定許多個地點，設立 p 個聯絡站，使得每一個地點皆可被其中一間聯絡站聯絡到。令聯絡距離的最大值最小。</p>
<img src="./Location Allocation Problem_files/p-CenterProblem1.png">
<p>也可以想做是：各個聯絡站各自使用一個圓，以自己為圓心，向外擴張以包住其負責的地點，然後讓最大的圓的半徑越小越好。</p>
<img src="./Location Allocation Problem_files/p-CenterProblem2.png">
<p>p-Center Problem 的主要應用是設立基地台。基地台放送電波，地點距離越遠，就需要越多能量、耗費越多電能；跟地點個數無關。為了節省電能，所以要適當的安排基地台的位置，縮短電波的放送距離。</p>
<p>此處依舊討論一維版本。</p>
<img src="./Location Allocation Problem_files/p-CenterProblem3.png">
<p class="t">簡化問題、觀察問題：只有一個連絡站</p>
<p>聯絡站放在相離最遠的兩個地點的正中央是最好的。應該不用證明了吧？</p>
<img src="./Location Allocation Problem_files/p-CenterProblem4.png">
<p>其他性質皆與 p-Median Problem 類似，不再複述。</p>
<p>p-Center Problem 可以重新想成：依照地緣，所有地點分配成 p 個區域，找出最寬的區域，其寬度的一半，即是答案。</p>
<img src="./Location Allocation Problem_files/p-CenterProblem5.png">
<p class="t">簡化問題、觀察問題：分區</p>
<p>p-Center Problem 只關心最寬的區域，其餘區域的寬度根本無所謂，不要超過最寬的區域就好了。</p>
<p class="t">動態規劃： Monotonicity</p>
<p>p-Center Problem 特性更強。分界線往右移動，一旦左方最寬的區域的寬度（的一半），大於等於右方區域的寬度（的一半），分界線就沒有必要繼續往右移動。往右移動只會讓答案更大。</p>
<img src="./Location Allocation Problem_files/p-CenterProblem6.png">
<p>p-Median Problem 僅掌握分界線的起點。 p-Center Problem 同時掌握起點與終點，時間複雜度為 O(NP) 。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">P</span><span>&nbsp;=&nbsp;</span><span class="value">3</span><span>,&nbsp;</span><span class="word">N</span><span>&nbsp;=&nbsp;</span><span class="value">6</span><span>;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;P為聯絡站個數，N為地點個數。</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;為了方便實作，數字右移一格。</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">location</span><span>[</span><span class="value">6</span><span>+</span><span class="value">1</span><span>]&nbsp;=&nbsp;{</span><span class="value">0</span><span>,&nbsp;</span><span class="value">2</span><span>,&nbsp;</span><span class="value">6</span><span>,&nbsp;</span><span class="value">11</span><span>,&nbsp;</span><span class="value">14</span><span>,&nbsp;</span><span class="value">18</span><span>,&nbsp;</span><span class="value">26</span><span>};&nbsp;&nbsp;</span><span class="comment">//&nbsp;需要排序</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">f</span><span>[</span><span class="value">3</span><span>+</span><span class="value">1</span><span>][</span><span class="value">6</span><span>+</span><span class="value">1</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;DP表格</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">r</span><span>[</span><span class="value">3</span><span>+</span><span class="value">1</span><span>][</span><span class="value">6</span><span>+</span><span class="value">1</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;記錄最佳的分界線位置。</span></li><li>&nbsp;</li><li><span class="keyword">inline</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">d</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">location</span><span>[</span><span class="word">j</span><span>]&nbsp;-&nbsp;</span><span class="word">location</span><span>[</span><span class="word">i</span><span>];</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">p_Center</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;Dynamic&nbsp;Programming。求出最寬的區域最窄可為多少。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">memset</span><span>(</span><span class="word">f</span><span>,&nbsp;</span><span class="hex">0x7f</span><span>,&nbsp;</span><span class="keyword">sizeof</span><span>(</span><span class="word">f</span><span>));&nbsp;</span><span class="comment">//&nbsp;初始化為無限大</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">f</span><span>[</span><span class="value">0</span><span>][</span><span class="value">0</span><span>]&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">p</span><span>=</span><span class="value">2</span><span>;&nbsp;</span><span class="word">p</span><span>&lt;=</span><span class="word">P</span><span>;&nbsp;++</span><span class="word">p</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>=</span><span class="value">1</span><span>,&nbsp;</span><span class="word">k</span><span>=</span><span class="value">1</span><span>;&nbsp;</span><span class="word">n</span><span>&lt;=</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">n</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;找出最佳的分界線</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">k</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">n</span><span>&nbsp;&amp;&amp;&nbsp;</span><span class="word">f</span><span>[</span><span class="word">p</span><span>-</span><span class="value">1</span><span>][</span><span class="word">k</span><span>-</span><span class="value">1</span><span>]&nbsp;&lt;=&nbsp;</span><span class="word">d</span><span>(</span><span class="word">k</span><span>,&nbsp;</span><span class="word">n</span><span>))&nbsp;</span><span class="word">k</span><span>++;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">k</span><span>--;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;用最佳的分界線，算得子問題的答案。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">f</span><span>[</span><span class="word">p</span><span>][</span><span class="word">n</span><span>]&nbsp;=&nbsp;</span><span class="word">f</span><span>[</span><span class="word">p</span><span>-</span><span class="value">1</span><span>][</span><span class="word">k</span><span>-</span><span class="value">1</span><span>]&nbsp;+&nbsp;</span><span class="word">d</span><span>(</span><span class="word">k</span><span>,&nbsp;</span><span class="word">n</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">r</span><span>[</span><span class="word">p</span><span>][</span><span class="word">n</span><span>]&nbsp;=&nbsp;</span><span class="word">k</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;從第k個位置往右到第j個位置</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;都屬於這個區域</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="string">"「最寬的區域」最窄為"</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="word">f</span><span>[</span><span class="word">P</span><span>][</span><span class="word">N</span><span>];</span></li><li><span>}</span></li></ol></div>
<p class="t">試誤法：窮舉最寬的區域的寬度</p>
<p>p-Center Problem 只關心最寬的區域。這種情況下，可以直接令每個區域都一樣大，跟最寬的區域一樣大，從第一個地點開始分區，儘量涵蓋越多地點。若能涵蓋全部地點，表示此寬度可行。</p>
<p>「最寬的區域」寬度適中，區域數量正確，可能是答案。</p>
<p>「最寬的區域」寬度太大，區域數量太少，可能是答案。</p>
<p>「最寬的區域」寬度太小，區域數量太多，不可能是答案。</p>
<img src="./Location Allocation Problem_files/p-CenterProblem7.png">
<p>寬度總共 O(N²) 種，驗證一種寬度需時 O(N) ，時間複雜度為 O(N³) 。</p>
<p>或者實施排序、二分搜尋，時間複雜度為 O(N²logN) 。</p>
<p>或者 length(i,j) 是已排序矩陣，樓梯搜尋，時間複雜度為 O(N²) ；二維二分搜尋，時間複雜度為 O(NlogN) 。</p>
<p>或者寬度取實際數值。下限是 0 ，上限是最遠的兩個地點的距離 L 。時間複雜度為 O(NlogL) 。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">P</span><span>&nbsp;=&nbsp;</span><span class="value">3</span><span>,&nbsp;</span><span class="word">N</span><span>&nbsp;=&nbsp;</span><span class="value">6</span><span>;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;P為聯絡站個數，N為地點個數。</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;為了方便實作，數字右移一格。</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">location</span><span>[</span><span class="value">6</span><span>+</span><span class="value">1</span><span>]&nbsp;=&nbsp;{</span><span class="value">0</span><span>,&nbsp;</span><span class="value">2</span><span>,&nbsp;</span><span class="value">6</span><span>,&nbsp;</span><span class="value">11</span><span>,&nbsp;</span><span class="value">14</span><span>,&nbsp;</span><span class="value">18</span><span>,&nbsp;</span><span class="value">26</span><span>};&nbsp;&nbsp;</span><span class="comment">//&nbsp;需要排序</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;計算分區數目</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">interval_number</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">max_interval_width</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">count</span><span>&nbsp;=&nbsp;</span><span class="value">1</span><span>,&nbsp;</span><span class="word">s</span><span>&nbsp;=&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">1</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;=</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;如果目前的點已經超過區域範圍了，則需要增加一個區域。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">location</span><span>[</span><span class="word">i</span><span>]&nbsp;-&nbsp;</span><span class="word">location</span><span>[</span><span class="word">s</span><span>]&nbsp;&gt;&nbsp;</span><span class="word">max_interval_width</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">s</span><span>&nbsp;=&nbsp;</span><span class="word">i</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">count</span><span>++;</span></li><li><span class="comment">//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;&gt;&nbsp;P)&nbsp;break;&nbsp;&nbsp;&nbsp;//&nbsp;偷吃步</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">count</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;從所有可能的答案中，找出正確答案。</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">BinarySearch</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">L</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">R</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">ans</span><span>&nbsp;=&nbsp;</span><span class="word">R</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">M</span><span>&nbsp;=&nbsp;(</span><span class="word">L</span><span>+</span><span class="word">R</span><span>)/</span><span class="value">2</span><span>;&nbsp;</span><span class="word">L</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">R</span><span>;&nbsp;</span><span class="word">M</span><span>&nbsp;=&nbsp;(</span><span class="word">L</span><span>+</span><span class="word">R</span><span>)/</span><span class="value">2</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;計算分區數目，並驗證答案。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">p</span><span>&nbsp;=&nbsp;</span><span class="word">interval_number</span><span>(</span><span class="word">M</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">p</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">P</span><span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;答案剛好或太大，繼續檢查有沒有更好的答案</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">R</span><span>&nbsp;=&nbsp;</span><span class="word">M</span><span>-</span><span class="value">1</span><span>,&nbsp;</span><span class="word">ans</span><span>&nbsp;=&nbsp;</span><span class="word">M</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;答案太小，不可能成為答案</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">L</span><span>&nbsp;=&nbsp;</span><span class="word">M</span><span>+</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">ans</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">p_Center</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">width</span><span>&nbsp;=&nbsp;</span><span class="word">BinarySearch</span><span>(</span><span class="value">0</span><span>,&nbsp;</span><span class="word">location</span><span>[</span><span class="word">N</span><span>]);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="string">"「最寬的區域」最窄為："</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="type">float</span><span>(</span><span class="word">width</span><span>)&nbsp;/&nbsp;</span><span class="value">2.0</span><span>;</span></li><li><span>}</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/7/714.html">714</a> <a href="http://uva.onlinejudge.org/external/114/11413.html">11413</a> <a href="http://uva.onlinejudge.org/external/9/907.html">907</a></p>

</div></div><div class="a" id="4"><div class="h">
<p class="b">p-Coverage Problem</p>
</div><div class="c">
<p>每個地點有半徑、支出、收入。連絡站建好後，涵蓋範圍為半徑、涵蓋到的地點有收入、沒涵蓋到的地點須支出，令總金額最高。</p>
</div></div><script src="./Location Allocation Problem_files/h.js.下载"></script><div class="m" style="left: 0px;"><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/index.html">◀ Index</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/LocationAllocationProblem.html#1">Location Allocation Problem</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/LocationAllocationProblem.html#2">p-Median Problem</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/LocationAllocationProblem.html#3">p-Center Problem</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/LocationAllocationProblem.html#4">p-Coverage Problem</a></div></div></body></html>