
<!-- saved from url=(0049)http://www.csie.ntnu.edu.tw/~u91029/Sequence.html -->
<html lang="zh-TW"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="./Sequence_files/style.css">
<title>演算法筆記 - Sequence</title></head><body>
<div class="a" id="1"><div class="h">
<p class="b">Sequence 資料結構 : <br> Array / List</p>
</div><div class="c">
<p class="t">Array</p>
<p>儲存一個數列，直覺的方式是使用一個陣列。</p>
<p>更新第 k 項： O(1) 。</p>
<p>插入第 k 項、刪除第 k 項：需要挪移資料。 O(N) 。</p>
<img src="./Sequence_files/Sequence1.png">
<p>區間總和、區間最大值、區間最小值：逐個累計。 O(N) 。</p>
<img src="./Sequence_files/Sequence2.png">
<p class="t">List</p>
<p>更新第 k 項、插入第 k 項、刪除第 k 項：需要定位。 O(N) 。</p>
<img src="./Sequence_files/Sequence3.png">
<p>區間總和、區間最大值、區間最小值：逐個累計。 O(N) 。</p>
<img src="./Sequence_files/Sequence4.png">
<p>串列與陣列的步驟數量，相比之下，顯然串列小於等於陣列 ── 然而兩者的時間複雜度都是 O(N) 。可以發現現行的時間複雜度標記方式，不是那麼精準，無法區分兩者的快慢差異。</p>
<p class="t">Unrolled Linked List</p>
<p>更新第 k 項： O(A) 。</p>
<p>插入第 k 項、刪除第 k 項： O(A + 2B) 到 O(2A + B) 。</p>
<p>使用 sqrt decomposition ，三者皆是 O(sqrtN) 。</p>
<img src="./Sequence_files/Sequence5.png">
<p>區間總和、區間最大值、區間最小值：每塊額外記錄數值，先查詢塊、再查詢元素。 O(A) 到 O(A + 2B) 。</p>
<p>使用 sqrt decomposition ，三者皆是 O(sqrtN) 。</p>
<img src="./Sequence_files/Sequence6.png">
<p>如果只需更新、查詢，不需插入、刪除，此時可以用陣列代替串列，容易實作。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/120/12003.html">12003</a> <a href="http://uva.onlinejudge.org/external/119/11922.html">11922</a> <a href="http://uva.onlinejudge.org/external/119/11990.html">11990</a> <a href="http://uva.onlinejudge.org/external/123/12345.html">12345</a></p>

</div></div><div class="a" id="2"><div class="h">
<p class="b">Sequence 資料結構 : <br> Binary Search Tree</p>
</div><div class="c">
<p class="t">粗淺的理解、錯誤的方式</p>
<p>既然 BST 是儲存大量數字的資料結構，我們嘗試運用 BST 來儲存一個數列。</p>
<p>數列的索引值是有序的， BST 是有序的，我們嘗試以索引值大小順序，做為 BST 的排序依據。 BST 的每個節點，額外記錄數列的數值。</p>
<img src="./Sequence_files/Sequence7.png">
<p>雖然可以迅速更新第 k 項，但是無法迅速插入第 k 項、刪除第 k 項，索引值無法保持連續整數。</p>
<img src="./Sequence_files/Sequence8.png">
<p class="t">深刻的理解、正確的方式</p>
<p>Search Tree 、 Heap 的功能是排順序，排序依據不見得得是數字大小順序，排序依據也不見得要儲存於節點之中。比如圖論領域的資料結構「<a href="http://www.csie.ntnu.edu.tw/~u91029/Graph2.html"> Link-Cut Tree </a>」所使用的 BST ，排序依據是樹上節點的父子順序。</p>
<p>令左子樹是索引值較小的項、右子樹是索引值較大的項。排序依據，仍是索引值大小順序，但是排序依據不必儲存於節點之中。</p>
<img src="./Sequence_files/Sequence9.png">
<p>更新第 k 項：就是找到 BST 第 k 名。 BST 的每個節點，額外記錄子樹的節點個數，以便快速得到名次。</p>
<p>插入第 k 項：先找到 BST 第 k 名，如果沒有右小孩，就挪至右小孩；如果擁有右小孩，就挪至次大節點（即 BST 第 k+1 名）的左小孩。然後原本第 k 名的位置，存入數列第 k 項。最後記得更新擴充資訊，由樹葉往樹根方向。</p>
<p>刪除第 k 項：先找到 BST 第 k 名，如果沒有小孩，就直接刪除；如果擁有左小孩、沒有右小孩，就拿左子樹頂替第 k 名；如果擁有左小孩、擁有右小孩，就拿次大節點頂替第 k 名，再拿次大節點的右子樹頂替次大節點（此時次大節點無左小孩）。最後記得更新擴充資訊，由樹葉往樹根方向。</p>
<p>不必死背這些流程。只要細心觀察 BST ，很容易推理出來。</p>
<img src="./Sequence_files/Sequence10.png">
<p>如果旋轉節點、平衡 BST ，那麼更新、插入、刪除、尋找次大節點的時間複雜度從 O(N) 變成 O(logN) 。</p>
<p>區間總和、區間最大值、區間最小值：每個節點額外記錄該子樹所有節點的總和、最小值、最大值！交給讀者。</p>
<p>任意區間的最大（小）區間和：交給讀者。</p>

</div></div><div class="a" id="3"><div class="h">
<p class="b">Sequence 資料結構 : <br> “Fake” Segment Tree</p>
</div><div class="c">
<p class="t">“Fake” Segment Tree 【尚無正式名稱】</p>
<p>此資料結構由競賽選手發明，沒有發表為正式的學術論文。目前發現最早出現於<a href="http://www.oi.edu.pl/static/attachment/20110713/boi-2001.pdf"> Baltic OI 2001: Mars Maps </a>，官方解答提供了此資料結構的程式碼。</p>
<p>此資料結構最初沒有特定名稱。傳入中國之後，競賽選手將名稱定調為 Segment Tree ，創造大量相關題型，例如<a href="http://www.spoj.com/problems/GSS3/"> SPOJ: GSS3 </a>，令 Segment Tree 之名稱被發揚光大。然而「<a href="http://www.csie.ntnu.edu.tw/~u91029/Position.html"> Segment Tree </a>」是既有的資料結構名稱，所以此資料結構勢必另取他名，以免混淆。</p>
<img src="./Sequence_files/FakeSegmentTree1.png">
<p class="t">建立資料結構</p>
<p>遞迴二分區間，樹葉存放數列，一個樹葉儲存一項；非樹葉存放擴充資訊，諸如區間總和、區間最大值、區間最小值。</p>
<p>節點最多是 2N-1 個，空間複雜度為 O(N) ，時間複雜度為 O(N) 。 N 為數列長度。</p>
<img src="./Sequence_files/FakeSegmentTree2.png">
<p class="t">更新第 k 項、區間總和、區間最大值、區間最小值</p>
<p>類似二元搜尋樹，時間複雜度為樹的深度 O(logN) 。</p>
<img src="./Sequence_files/FakeSegmentTree3.png">
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[</span><span class="value">1</span><span>&lt;&lt;</span><span class="value">9</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;數列</span></li><li>&nbsp;</li><li><span class="keyword">struct</span><span>&nbsp;</span><span class="word">Node</span></li><li><span>{</span></li><li><span class="comment">//&nbsp;&nbsp;int&nbsp;L,&nbsp;R;&nbsp;&nbsp;&nbsp;//&nbsp;其下所有樹葉的數列索引值範圍</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">sum</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;其下所有樹葉的區間總和</span></li><li><span class="comment">//&nbsp;&nbsp;int&nbsp;min;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其下所有樹葉的區間最小值</span></li><li><span class="comment">//&nbsp;&nbsp;int&nbsp;max;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其下所有樹葉的區間最大值</span></li><li><span>}&nbsp;</span><span class="word">node</span><span>[</span><span class="value">1</span><span>&lt;&lt;</span><span class="value">10</span><span>];&nbsp;&nbsp;</span><span class="comment">//&nbsp;用陣列模擬二元樹</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;用陣列模擬二元樹：左小孩、右小孩</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">LC</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)&nbsp;{</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">i</span><span>*</span><span class="value">2</span><span>;}</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">RC</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)&nbsp;{</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">i</span><span>*</span><span class="value">2</span><span>+</span><span class="value">1</span><span>;}</span></li><li>&nbsp;</li><li><span class="comment">//int&nbsp;sum[1&lt;&lt;10];&nbsp;&nbsp;&nbsp;//&nbsp;更簡便的寫法</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">build</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">L</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">L</span><span>&nbsp;==&nbsp;</span><span class="word">R</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;設定樹葉的數值</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">sum</span><span>&nbsp;=&nbsp;</span><span class="word">array</span><span>[</span><span class="word">L</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">M</span><span>&nbsp;=&nbsp;(</span><span class="word">L</span><span>&nbsp;+&nbsp;</span><span class="word">R</span><span>)&nbsp;/&nbsp;</span><span class="value">2</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">build</span><span>(</span><span class="word">L</span><span>&nbsp;&nbsp;,&nbsp;</span><span class="word">M</span><span>,&nbsp;</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>));&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;遞迴建立左子樹</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">build</span><span>(</span><span class="word">M</span><span>+</span><span class="value">1</span><span>,&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>));&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;遞迴建立右子樹</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;回溯時順便計算總和</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">sum</span><span>&nbsp;=&nbsp;</span><span class="word">node</span><span>[</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>)].</span><span class="word">sum</span><span>&nbsp;+&nbsp;</span><span class="word">node</span><span>[</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>)].</span><span class="word">sum</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">x</span><span>,&nbsp;</span><span class="word">n</span><span>;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;更新位置、數值大小</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">update</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">L</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">L</span><span>&nbsp;==&nbsp;</span><span class="word">R</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">sum</span><span>&nbsp;=&nbsp;</span><span class="word">n</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">M</span><span>&nbsp;=&nbsp;(</span><span class="word">L</span><span>&nbsp;+&nbsp;</span><span class="word">R</span><span>)&nbsp;/&nbsp;</span><span class="value">2</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">M</span><span>)&nbsp;</span><span class="word">update</span><span>(</span><span class="word">L</span><span>&nbsp;&nbsp;,&nbsp;</span><span class="word">M</span><span>,&nbsp;</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>));&nbsp;&nbsp;</span><span class="comment">//&nbsp;遞迴更新左子樹</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x</span><span>&nbsp;&gt;&nbsp;&nbsp;</span><span class="word">M</span><span>)&nbsp;</span><span class="word">update</span><span>(</span><span class="word">M</span><span>+</span><span class="value">1</span><span>,&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>));&nbsp;&nbsp;</span><span class="comment">//&nbsp;遞迴更新右子樹</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;回溯時順便更新總和</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">sum</span><span>&nbsp;=&nbsp;</span><span class="word">node</span><span>[</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>)].</span><span class="word">sum</span><span>&nbsp;+&nbsp;</span><span class="word">node</span><span>[</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>)].</span><span class="word">sum</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">x1</span><span>,&nbsp;</span><span class="word">x2</span><span>,&nbsp;</span><span class="word">total</span><span>;&nbsp;&nbsp;</span><span class="comment">//&nbsp;查詢範圍[x1,x2]並且累計總和</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">query</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">L</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x1</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">L</span><span>&nbsp;&amp;&amp;&nbsp;</span><span class="word">R</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">x2</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">total</span><span>&nbsp;+=&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">sum</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">M</span><span>&nbsp;=&nbsp;(</span><span class="word">L</span><span>&nbsp;+&nbsp;</span><span class="word">R</span><span>)&nbsp;/&nbsp;</span><span class="value">2</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x1</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">M</span><span>)&nbsp;</span><span class="word">query</span><span>(</span><span class="word">L</span><span>&nbsp;&nbsp;,&nbsp;</span><span class="word">M</span><span>,&nbsp;</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>));&nbsp;&nbsp;</span><span class="comment">//&nbsp;遞迴查詢左子樹</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x2</span><span>&nbsp;&gt;&nbsp;&nbsp;</span><span class="word">M</span><span>)&nbsp;</span><span class="word">query</span><span>(</span><span class="word">M</span><span>+</span><span class="value">1</span><span>,&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>));&nbsp;&nbsp;</span><span class="comment">//&nbsp;遞迴查詢右子樹</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">demo</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;建立索引值0到99的偽線段樹。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="value">100</span><span>;&nbsp;++</span><span class="word">i</span><span>)&nbsp;</span><span class="word">cin</span><span>&nbsp;&gt;&gt;&nbsp;</span><span class="word">value</span><span>[</span><span class="word">i</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">build</span><span>(</span><span class="value">0</span><span>,&nbsp;</span><span class="value">99</span><span>,&nbsp;</span><span class="value">1</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;索引值為5的元素，更新為7。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>&nbsp;=&nbsp;</span><span class="value">5</span><span>;&nbsp;</span><span class="word">n</span><span>&nbsp;=&nbsp;</span><span class="value">7</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">update</span><span>(</span><span class="value">0</span><span>,&nbsp;</span><span class="value">99</span><span>,&nbsp;</span><span class="value">1</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;查詢區間[3,3]的總和。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x1</span><span>&nbsp;=&nbsp;</span><span class="value">3</span><span>;&nbsp;</span><span class="word">x2</span><span>&nbsp;=&nbsp;</span><span class="value">3</span><span>;&nbsp;</span><span class="word">total</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">query</span><span>(</span><span class="value">0</span><span>,&nbsp;</span><span class="value">99</span><span>,&nbsp;</span><span class="value">1</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="word">total</span><span>;</span></li><li><span>}</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/112/11297.html">11297</a> <a href="http://uva.onlinejudge.org/external/122/12299.html">12299</a></p>
<p class="t">插入第 k 項、刪除第 k 項</p>
<p>不負責任地交給讀者。</p>
<p class="t">任意區間的最大（小）區間和</p>
<p>不負責任地交給讀者。</p>
<p class="e">ICPC <a href="http://icpcarchive.ecs.baylor.edu/external/39/3938.pdf">3938</a></p>
<p class="t">推廣到高維度</p>
<p>偽線段樹可以推廣到高維度，從一維數列變成二維陣列、三維陣列。二維偽線段樹，是先製作一棵第一維度的偽線段樹（稱作 X 樹），然後每個節點各自接上一棵第二維度的偽線段樹（稱作 Y 樹）。中文網路稱作「樹套樹」。</p>
<img src="./Sequence_files/FakeSegmentTree4.png">
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/126/12698.html">12698</a></p>
<p class="t">更新區間：楔子</p>
<p>偽線段樹也可以更新區間。首先簡化問題，把數值改成顏色。如果區間不是相同顏色，就繼續遞迴對半分割下去。如果區間是相同顏色，暫且不分割！</p>
<img src="./Sequence_files/LazyPropagation1.png">
<p>更新第 k 項，有三大步驟：一、搜尋之時，原有顏色分離，挪往下層。二、就位之時，直接覆蓋顏色，刪除子樹（或者無視子樹）。三、回溯之時，相同顏色合併，挪往上層。</p>
<p>此番技巧尚未有正式名稱，英文網路稱作「 lazy propagation 」，中文網路稱作「延遲標記」。</p>
<img src="./Sequence_files/LazyPropagation2.png">
<img src="./Sequence_files/LazyPropagation3.png">
<img src="./Sequence_files/LazyPropagation4.png">
<p>更新區間：視情況左右子樹都得走，並分割更新區間。</p>
<img src="./Sequence_files/LazyPropagation5.png">
<p>查詢第 k 項：一旦遭遇顏色，即得答案，不必深入子孫。</p>
<img src="./Sequence_files/LazyPropagation6.png">
<p>查詢區間顏色是否一致：視情況左右子樹都得走，並分割查詢區間。當節點區間大於等於查詢區間時，一旦遭遇顏色，即可判斷異同，不必深入子孫。當節點區間小於等於查詢區間時，一旦遭遇無色，即得答案為否，不必深入子孫。不能推廣到高維度。</p>
<img src="./Sequence_files/LazyPropagation7.png">
<img src="./Sequence_files/LazyPropagation8.png">
<p>這四項操作的時間複雜度都是 O(logN) 。</p>
<p class="t">更新區間：統統改為一數值</p>
<p>更新第 k 項、更新區間：運用「 lazy propagation 」技巧，凡遭遇已改值的區間，則分離挪往下層。</p>
<p>查詢第 k 項、查詢區間：凡遭遇已改值的區間，即得答案，不必深入子孫。</p>
<p>查詢區間不能推廣到高維度。</p>
<img src="./Sequence_files/FakeSegmentTree5.png">
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">build</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">L</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">L</span><span>&nbsp;==&nbsp;</span><span class="word">R</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>&nbsp;=&nbsp;</span><span class="word">array</span><span>[</span><span class="word">L</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;內部節點初始化為沒有設值</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>&nbsp;=&nbsp;</span><span class="value">1e9</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">M</span><span>&nbsp;=&nbsp;(</span><span class="word">L</span><span>&nbsp;+&nbsp;</span><span class="word">R</span><span>)&nbsp;&gt;&gt;&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">build</span><span>(</span><span class="word">L</span><span>&nbsp;&nbsp;,&nbsp;</span><span class="word">M</span><span>,&nbsp;</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>));</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">build</span><span>(</span><span class="word">M</span><span>+</span><span class="value">1</span><span>,&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>));</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;左右相同，合而為一。可不寫。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">node</span><span>[</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>)].</span><span class="word">set</span><span>&nbsp;==&nbsp;</span><span class="word">node</span><span>[</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>)].</span><span class="word">set</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>&nbsp;=&nbsp;</span><span class="word">node</span><span>[</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>)].</span><span class="word">set</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">x1</span><span>,&nbsp;</span><span class="word">x2</span><span>,&nbsp;</span><span class="word">set</span><span>;</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">update</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">L</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x1</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">L</span><span>&nbsp;&amp;&amp;&nbsp;</span><span class="word">R</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">x2</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>&nbsp;=&nbsp;</span><span class="word">set</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;已經設值，恰好相同。可不寫。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>&nbsp;==&nbsp;</span><span class="word">set</span><span>)&nbsp;</span><span class="keyword">return</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;一分為二，撥草找路。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>&nbsp;!=&nbsp;</span><span class="value">1e9</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>)].</span><span class="word">set</span><span>&nbsp;=&nbsp;</span><span class="word">node</span><span>[</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>)].</span><span class="word">set</span><span>&nbsp;=&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>&nbsp;=&nbsp;</span><span class="value">1e9</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">M</span><span>&nbsp;=&nbsp;(</span><span class="word">L</span><span>&nbsp;+&nbsp;</span><span class="word">R</span><span>)&nbsp;/&nbsp;</span><span class="value">2</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x1</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">M</span><span>)&nbsp;</span><span class="word">update</span><span>(</span><span class="word">L</span><span>&nbsp;&nbsp;,&nbsp;</span><span class="word">M</span><span>,&nbsp;</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>));</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x2</span><span>&nbsp;&gt;&nbsp;&nbsp;</span><span class="word">M</span><span>)&nbsp;</span><span class="word">update</span><span>(</span><span class="word">M</span><span>+</span><span class="value">1</span><span>,&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>));</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">x</span><span>,&nbsp;</span><span class="word">n</span><span>;</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">query</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">L</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)</span></li><li><span>{</span></li><li><span class="comments">/*</span></li><li><span class="comments">&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;已被下方程式碼處理掉，不必寫。</span></li><li><span class="comments">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L&nbsp;==&nbsp;R)</span></li><li><span class="comments">&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span class="comments">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;node[i].set;</span></li><li><span class="comments">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span></li><li><span class="comments">&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span class="comments">*/</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>&nbsp;!=&nbsp;</span><span class="value">1e9</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">n</span><span>&nbsp;=&nbsp;</span><span class="word">node</span><span>[</span><span class="word">i</span><span>].</span><span class="word">set</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">M</span><span>&nbsp;=&nbsp;(</span><span class="word">L</span><span>&nbsp;+&nbsp;</span><span class="word">R</span><span>)&nbsp;/&nbsp;</span><span class="value">2</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">M</span><span>)&nbsp;</span><span class="word">query</span><span>(</span><span class="word">L</span><span>&nbsp;&nbsp;,&nbsp;</span><span class="word">M</span><span>,&nbsp;</span><span class="word">LC</span><span>(</span><span class="word">i</span><span>));</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x</span><span>&nbsp;&gt;&nbsp;&nbsp;</span><span class="word">M</span><span>)&nbsp;</span><span class="word">query</span><span>(</span><span class="word">M</span><span>+</span><span class="value">1</span><span>,&nbsp;</span><span class="word">R</span><span>,&nbsp;</span><span class="word">RC</span><span>(</span><span class="word">i</span><span>));</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">demo</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;建立索引值0到99的偽線段樹。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="value">100</span><span>;&nbsp;++</span><span class="word">i</span><span>)&nbsp;</span><span class="word">cin</span><span>&nbsp;&gt;&gt;&nbsp;</span><span class="word">value</span><span>[</span><span class="word">i</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">build</span><span>(</span><span class="value">0</span><span>,&nbsp;</span><span class="value">99</span><span>,&nbsp;</span><span class="value">1</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;區間[3,3]所有數值改為5。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x1</span><span>&nbsp;=&nbsp;</span><span class="value">3</span><span>;&nbsp;</span><span class="word">x2</span><span>&nbsp;=&nbsp;</span><span class="value">3</span><span>;&nbsp;</span><span class="word">total</span><span>&nbsp;=&nbsp;</span><span class="value">5</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">update</span><span>(</span><span class="value">0</span><span>,&nbsp;</span><span class="value">99</span><span>,&nbsp;</span><span class="value">1</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;查詢第5個元素。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>&nbsp;=&nbsp;</span><span class="value">5</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">query</span><span>(</span><span class="value">0</span><span>,&nbsp;</span><span class="value">99</span><span>,&nbsp;</span><span class="value">1</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="word">n</span><span>;</span></li><li><span>}</span></li></ol></div>
<p class="t">更新區間：統統增減一數值</p>
<p>更新第 k 項、更新區間：直接在對應區間累計增減值。</p>
<p>查詢第 k 項：累加路線上的增減值。</p>
<p>似乎無法查詢區間。</p>
<p>這似乎也被歸類於「 lazy propagation 」技巧。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/114/11402.html">11402</a> <a href="http://uva.onlinejudge.org/external/119/11992.html">11992</a></p>
<p class="t">Bottom-up “Fake” Segment Tree 【尚無正式名稱】</p>
<p>BST 和 FST 要實作很久，趕時間的競賽選手避之唯恐不及。如果不需要插入第 k 項、刪除第 k 項，只需要更新第 k 項、查詢區間，此時就可以採用特殊資料結構，編寫較少程式碼。</p>
<pre>只能更新第k項、查詢區間：Bottom-up “Fake” Segment Tree
只能更新第k項、查詢區間總和：Binary Indexed Tree
只能更新第k項、查詢區間極值：Sparse Table
</pre>
<p>2010 年由競賽選手清华大学张昆玮《<a href="http://www.slideshare.net/DanielChou/ss-7792670">统计的力量 —— 线段树全接触</a>》提出。我不清楚是否已有正式學術論文。</p>
<p>讀者須具備「<a href="http://www.csie.ntnu.edu.tw/~u91029/C++.html"> Bitwise Operation </a>」基礎。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[(</span><span class="value">1</span><span>&lt;&lt;</span><span class="value">9</span><span>)-</span><span class="value">2</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;數列</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">sum</span><span>[</span><span class="value">1</span><span>&lt;&lt;</span><span class="value">10</span><span>],&nbsp;</span><span class="word">T</span><span>;</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">build</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="word">T</span><span>=</span><span class="value">1</span><span>;&nbsp;</span><span class="word">T</span><span>&lt;</span><span class="word">N</span><span>+</span><span class="value">2</span><span>;&nbsp;</span><span class="word">T</span><span>&lt;&lt;=</span><span class="value">1</span><span>)&nbsp;;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">T</span><span>]&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">T</span><span>+</span><span class="value">1</span><span>+</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(++</span><span class="word">i</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">T</span><span>;&nbsp;++</span><span class="word">i</span><span>)&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">T</span><span>+</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="word">i</span><span>=</span><span class="word">T</span><span>-</span><span class="value">1</span><span>;&nbsp;</span><span class="word">i</span><span>;&nbsp;--</span><span class="word">i</span><span>)&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="word">sum</span><span>[</span><span class="value">2</span><span>*</span><span class="word">i</span><span>]&nbsp;+&nbsp;</span><span class="word">sum</span><span>[</span><span class="value">2</span><span>*</span><span class="word">i</span><span>+</span><span class="value">1</span><span>];</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;更新範圍[i,i]、更新為數值n</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">update</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">i</span><span>&nbsp;+=&nbsp;</span><span class="word">T</span><span>]&nbsp;=&nbsp;</span><span class="word">n</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(;&nbsp;</span><span class="word">i</span><span>^</span><span class="value">1</span><span>;&nbsp;</span><span class="word">i</span><span>&gt;&gt;=</span><span class="value">1</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">i</span><span>&gt;&gt;</span><span class="value">1</span><span>]&nbsp;=&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">i</span><span>]&nbsp;+&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">i</span><span>^</span><span class="value">1</span><span>];</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;查詢範圍[i,j]並且累計總和</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">query</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="word">i</span><span>+=</span><span class="word">T</span><span>-</span><span class="value">1</span><span>,&nbsp;</span><span class="word">j</span><span>+=</span><span class="word">T</span><span>+</span><span class="value">1</span><span>;&nbsp;</span><span class="word">i</span><span>^</span><span class="word">j</span><span>^</span><span class="value">1</span><span>;&nbsp;</span><span class="word">i</span><span>&gt;&gt;=</span><span class="value">1</span><span>,&nbsp;</span><span class="word">j</span><span>&gt;&gt;=</span><span class="value">1</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(~</span><span class="word">i</span><span>&nbsp;&amp;&nbsp;</span><span class="value">1</span><span>)&nbsp;</span><span class="word">n</span><span>&nbsp;+=&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">i</span><span>^</span><span class="value">1</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">j</span><span>&nbsp;&amp;&nbsp;</span><span class="value">1</span><span>)&nbsp;</span><span class="word">n</span><span>&nbsp;+=&nbsp;</span><span class="word">sum</span><span>[</span><span class="word">j</span><span>^</span><span class="value">1</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">n</span><span>;</span></li><li><span>}</span></li></ol></div>

</div></div><div class="a" id="4"><div class="h">
<p class="b">Sequence 資料結構 : <br> Binary Indexed Tree</p>
</div><div class="c">
<p class="t">Binary Indexed Tree （ Fenwick Tree ）</p>
<p>存放一串數列，可以快速算出任意區間的總和。</p>
<p>可以更新數值，但是不能插入、刪除數值。</p>
<p>閒置陣列第零格。觀察前綴和，切割成數段。切割方向：索引值由小到大。切割長度：二的次方，數量級盡量大。</p>
<img src="./Sequence_files/BinaryIndexedTree1.png">
<p>索引值化作二進位，上述行為即是：索引值逐次刪去最低位的 1 。</p>
<pre>10的二進位是1010。
刪去最低位的1，切割成 1010 ~ 1000+1，剩下1000。
刪去最低位的1，切割成 1000 ~ 0000+1，剩下0000，結束。

7的二進位是111。
刪去最低位的1，切割成 111 ~ 110+1，剩下110。
刪去最低位的1，切割成 110 ~ 100+1，剩下100。
刪去最低位的1，切割成 100 ~ 000+1，剩下000，結束。
</pre>
<img src="./Sequence_files/BinaryIndexedTree2.png">
<p>每種前綴和，皆實施切割，總共只有 N 種區段！ N 個區段和，依序儲存於陣列，得到 Binary Indexed Tree 。是陣列、不是樹。</p>
<img src="./Sequence_files/BinaryIndexedTree3.png">
<p>Binary Indexed Tree 得視作偽線段樹的精簡版本：擴充資訊是區間總和；移除樹根及全部右小孩。</p>
<img src="./Sequence_files/BinaryIndexedTree4.png">
<p class="t">計算第 1 項到第 k 項的總和</p>
<p>挑出對應的區段，進行累加。</p>
<img src="./Sequence_files/BinaryIndexedTree5.png">
<p class="t">更新一項數值</p>
<p>看看哪些區段包含這一項，補上差值。</p>
<img src="./Sequence_files/BinaryIndexedTree6.png">
<p class="t">複雜度</p>
<p>建立時間為 O(NlogN) ，建立空間為 O(N) ，更新一項數值的時間是 O(logN) ，計算任意區間總和的時間是 O(logN) 。</p>
<p>註：採用偽線段樹的建立手法，建立時間變為 O(N) 。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>&nbsp;=&nbsp;</span><span class="value">10000000</span><span>;</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">t</span><span>[</span><span class="word">N</span><span>+</span><span class="value">1</span><span>];&nbsp;</span><span class="comment">//&nbsp;第零格無作用，數列是從第一項到第N項。</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;快速求出最低位的bit。這是其中一種方式。</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">lower_bit</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">n</span><span>&nbsp;&amp;&nbsp;-</span><span class="word">n</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;value[1]&nbsp;+&nbsp;value[2]&nbsp;+&nbsp;...&nbsp;+&nbsp;value[n]</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">sum</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">s</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">n</span><span>&nbsp;&gt;&nbsp;</span><span class="value">0</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">s</span><span>&nbsp;+=&nbsp;</span><span class="word">t</span><span>[</span><span class="word">n</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">n</span><span>&nbsp;-=&nbsp;</span><span class="word">lower_bit</span><span>(</span><span class="word">n</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">s</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;value[n]&nbsp;+=&nbsp;d</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">add</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">d</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">n</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">n</span><span>]&nbsp;+=&nbsp;</span><span class="word">d</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">n</span><span>&nbsp;+=&nbsp;</span><span class="word">lower_bit</span><span>(</span><span class="word">n</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;value[a]&nbsp;+&nbsp;value[a+1]&nbsp;+&nbsp;...&nbsp;+&nbsp;value[b]</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">query</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">a</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">b</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>&nbsp;&gt;&nbsp;</span><span class="word">b</span><span>)&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">a</span><span>,&nbsp;</span><span class="word">b</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">sum</span><span>(</span><span class="word">b</span><span>)&nbsp;-&nbsp;</span><span class="word">sum</span><span>(</span><span class="word">a</span><span>-</span><span class="value">1</span><span>);</span></li><li><span>}</span></li></ol></div>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>&nbsp;=&nbsp;</span><span class="value">10000000</span><span>;</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">t</span><span>[</span><span class="word">N</span><span>];&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;數列是從第零項到第N-1項。</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;value[0]&nbsp;+&nbsp;value[1]&nbsp;+&nbsp;...&nbsp;+&nbsp;value[n]</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">sum</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">s</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">n</span><span>&nbsp;&gt;=&nbsp;</span><span class="value">0</span><span>)&nbsp;{</span><span class="word">s</span><span>&nbsp;+=&nbsp;</span><span class="word">t</span><span>[</span><span class="word">n</span><span>];&nbsp;</span><span class="word">n</span><span>&nbsp;=&nbsp;(</span><span class="word">n</span><span>&nbsp;&amp;&nbsp;(</span><span class="word">n</span><span>+</span><span class="value">1</span><span>))&nbsp;-&nbsp;</span><span class="value">1</span><span>;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">s</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;value[n]&nbsp;+=&nbsp;d</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">add</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">d</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">n</span><span>&nbsp;&lt;&nbsp;</span><span class="word">N</span><span>)&nbsp;{</span><span class="word">t</span><span>[</span><span class="word">n</span><span>]&nbsp;+=&nbsp;</span><span class="word">d</span><span>;&nbsp;</span><span class="word">n</span><span>&nbsp;|=&nbsp;</span><span class="word">n</span><span>&nbsp;+&nbsp;</span><span class="value">1</span><span>;}</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;value[a]&nbsp;+&nbsp;value[a+1]&nbsp;+&nbsp;...&nbsp;+&nbsp;value[b]</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">query</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">a</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">b</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>&nbsp;&gt;&nbsp;</span><span class="word">b</span><span>)&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">a</span><span>,&nbsp;</span><span class="word">b</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">sum</span><span>(</span><span class="word">b</span><span>)&nbsp;-&nbsp;</span><span class="word">sum</span><span>(</span><span class="word">a</span><span>-</span><span class="value">1</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;小心a-1可能是-1，會超過陣列邊界。</span></li><li><span>}</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/114/11423.html">11423</a> <a href="http://uva.onlinejudge.org/external/116/11610.html">11610</a></p>
<p class="t">推廣到高維度</p>
<p>Binary Indexed Tree 可以推廣到高維度，建立方法是逐步處理各維度。以二維為例：矩陣切成一條一條的橫條，每個橫條分別建立 BIT ，每個橫條都有 N 種區段；然後針對每一種區段，再分別建立垂直方向的 BIT 。</p>
<p>建立時間為 O(XlogX ⋅ YlogY ⋅ ...) ，建立空間為 O(XY...) ，更新一項數值的時間是 O(logX ⋅ logY ⋅ ...) ，計算任意矩形區域總和的時間是 O(2ᴰ ⋅ logX ⋅ logY ⋅ ...) 。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">X</span><span>&nbsp;=&nbsp;</span><span class="value">10000000</span><span>,&nbsp;</span><span class="word">Y</span><span>&nbsp;=&nbsp;</span><span class="value">10000000</span><span>;</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">t</span><span>[</span><span class="word">X</span><span>][</span><span class="word">Y</span><span>];</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;value[x][y]&nbsp;+=&nbsp;d</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">add</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">x</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">d</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;找出&nbsp;t[x]&nbsp;這個橫條</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">x</span><span>&nbsp;&lt;&nbsp;</span><span class="word">X</span><span>)&nbsp;{</span><span class="word">addy</span><span>(</span><span class="word">x</span><span>,&nbsp;</span><span class="word">y</span><span>,&nbsp;</span><span class="word">d</span><span>);&nbsp;</span><span class="word">x</span><span>&nbsp;|=&nbsp;</span><span class="word">x</span><span>&nbsp;+&nbsp;</span><span class="value">1</span><span>;}</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">addy</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">x</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">d</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">y</span><span>&nbsp;&lt;&nbsp;</span><span class="word">Y</span><span>)&nbsp;{</span><span class="word">t</span><span>[</span><span class="word">x</span><span>][</span><span class="word">y</span><span>]&nbsp;+=&nbsp;</span><span class="word">d</span><span>;&nbsp;</span><span class="word">y</span><span>&nbsp;|=&nbsp;</span><span class="word">y</span><span>&nbsp;+&nbsp;</span><span class="value">1</span><span>;}</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;sigma&nbsp;value[0~x][0~y]</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">sum</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">x</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">s</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">x</span><span>&nbsp;&gt;=&nbsp;</span><span class="value">0</span><span>)&nbsp;{</span><span class="word">s</span><span>&nbsp;+=&nbsp;</span><span class="word">sumy</span><span>(</span><span class="word">x</span><span>,&nbsp;</span><span class="word">y</span><span>);&nbsp;</span><span class="word">x</span><span>&nbsp;=&nbsp;(</span><span class="word">x</span><span>&nbsp;&amp;&nbsp;(</span><span class="word">x</span><span>+</span><span class="value">1</span><span>))&nbsp;-&nbsp;</span><span class="value">1</span><span>;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">s</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">sumy</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">x</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">s</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">y</span><span>&nbsp;&gt;=&nbsp;</span><span class="value">0</span><span>)&nbsp;{</span><span class="word">s</span><span>&nbsp;+=&nbsp;</span><span class="word">t</span><span>[</span><span class="word">x</span><span>][</span><span class="word">y</span><span>];&nbsp;</span><span class="word">y</span><span>&nbsp;=&nbsp;(</span><span class="word">y</span><span>&nbsp;&amp;&nbsp;(</span><span class="word">y</span><span>+</span><span class="value">1</span><span>))&nbsp;-&nbsp;</span><span class="value">1</span><span>;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">s</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">sum</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">x1</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">x2</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y1</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y2</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x1</span><span>&nbsp;&gt;&nbsp;</span><span class="word">x2</span><span>)&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">x1</span><span>,&nbsp;</span><span class="word">x2</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">y1</span><span>&nbsp;&gt;&nbsp;</span><span class="word">y2</span><span>)&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">y1</span><span>,&nbsp;</span><span class="word">y2</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;切成四個長方形，然後使用排容原理。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">sum</span><span>(</span><span class="word">x2</span><span>,&nbsp;</span><span class="word">y2</span><span>)&nbsp;-&nbsp;</span><span class="word">sum</span><span>(</span><span class="word">x1</span><span>-</span><span class="value">1</span><span>,&nbsp;</span><span class="word">y2</span><span>)&nbsp;-&nbsp;</span><span class="word">sum</span><span>(</span><span class="word">x2</span><span>,&nbsp;</span><span class="word">y1</span><span>-</span><span class="value">1</span><span>)&nbsp;+&nbsp;</span><span class="word">sum</span><span>(</span><span class="word">x1</span><span>-</span><span class="value">1</span><span>,&nbsp;</span><span class="word">y1</span><span>-</span><span class="value">1</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;小心x1-1、y1-1可能是-1，會超過陣列邊界。</span></li><li><span>}</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/116/11601.html">11601</a></p>

</div></div><div class="a" id="5"><div class="h">
<p class="b">Sequence 資料結構 : <br> Sparse Table</p>
</div><div class="c">
<p class="t">Sparse Table 【註：古代名稱，今日看來詞不達意。】</p>
<p>存放一串數列，可以快速算出任意區間，其中一個最小（大）值的所在位置。有人稱作 Range Minimum Query 問題。</p>
<p>不能更新、插入、刪除數值。</p>
<p>依序求出寬度為 1 、 2 、 4 、 8 、 …… 的區間最小值，區間的所有可能位置都要算一遍。兩個窄區間可以快速合成出一個寬區間。</p>
<img src="./Sequence_files/SparseTable1.png">
<p>將寬度為 1 、 2 、 4 、 8 、 …… 的區間最小值，儲存於表格。</p>
<pre>t(i, j) =
 { min{ t(i-1, j), t(i-1, j+2^(i-1) }  , if i &gt; 0
 { value[j]                            , if i = 0
</pre>
<img src="./Sequence_files/SparseTable2.png">
<p>實作時，通常表格中記錄的是索引值、指標，而不是直接記錄數值的最小值。</p>
<p class="t">計算區間最小值（的索引值）</p>
<p>查詢時，先從表格中找到寬度略短於（相等於）查詢區間的區間，以靠左、靠右的兩條等寬區間，求得查詢區間的最小值：</p>
<img src="./Sequence_files/SparseTable3.png">
<p class="t">複雜度</p>
<p>建立時間為 O(NlogN) ，建立空間為 O(NlogN) ，計算任意區間最小值的時間是 O(1) 。</p>
<div class="sh"><div class="bar">找出最小值的索引值</div><ol><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>&nbsp;=&nbsp;</span><span class="value">1000000</span><span>;</span></li><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">logN</span><span>&nbsp;=&nbsp;</span><span class="word">ceil</span><span>(</span><span class="word">log</span><span>(</span><span class="word">N</span><span>));</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">value</span><span>[</span><span class="word">N</span><span>];</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">t</span><span>[</span><span class="word">logN</span><span>][</span><span class="word">N</span><span>];&nbsp;</span><span class="comment">//&nbsp;t[i][j]儲存區間[j,&nbsp;j+2ⁱ-1]的最小值的索引值</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">construct</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;寬度為1的區間最小值</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="value">0</span><span>][</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="word">i</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;寬度為2、4、8、……的區間最小值</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">1</span><span>;&nbsp;(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">i</span><span>)-</span><span class="value">1</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)&nbsp;&nbsp;</span><span class="comment">//&nbsp;i&nbsp;&lt;&nbsp;logN</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">j</span><span>+(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">i</span><span>)-</span><span class="value">1</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&amp;&nbsp;</span><span class="word">L</span><span>&nbsp;=&nbsp;</span><span class="word">t</span><span>[</span><span class="word">i</span><span>-</span><span class="value">1</span><span>][</span><span class="word">j</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&amp;&nbsp;</span><span class="word">R</span><span>&nbsp;=&nbsp;</span><span class="word">t</span><span>[</span><span class="word">i</span><span>-</span><span class="value">1</span><span>][</span><span class="word">j</span><span>+(</span><span class="value">1</span><span>&lt;&lt;(</span><span class="word">i</span><span>-</span><span class="value">1</span><span>))];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">i</span><span>][</span><span class="word">j</span><span>]&nbsp;=&nbsp;(</span><span class="word">value</span><span>[</span><span class="word">L</span><span>]&nbsp;&lt;=&nbsp;</span><span class="word">value</span><span>[</span><span class="word">R</span><span>]&nbsp;?&nbsp;</span><span class="word">L</span><span>&nbsp;:&nbsp;</span><span class="word">R</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">query</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">a</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">b</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">d</span><span>&nbsp;=&nbsp;</span><span class="word">abs</span><span>(</span><span class="word">b</span><span>&nbsp;-&nbsp;</span><span class="word">a</span><span>)&nbsp;+&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">p</span><span>&nbsp;=&nbsp;</span><span class="value">31</span><span>&nbsp;-&nbsp;</span><span class="word">__builtin_clz</span><span>(</span><span class="word">d</span><span>);&nbsp;&nbsp;</span><span class="comment">//&nbsp;evil&nbsp;O(1)</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&amp;&nbsp;</span><span class="word">L</span><span>&nbsp;=&nbsp;</span><span class="word">t</span><span>[</span><span class="word">p</span><span>][</span><span class="word">a</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&amp;&nbsp;</span><span class="word">R</span><span>&nbsp;=&nbsp;</span><span class="word">t</span><span>[</span><span class="word">p</span><span>][</span><span class="word">b</span><span>-(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">p</span><span>)+</span><span class="value">1</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">value</span><span>[</span><span class="word">L</span><span>]&nbsp;&lt;=&nbsp;</span><span class="word">value</span><span>[</span><span class="word">R</span><span>]&nbsp;?&nbsp;</span><span class="word">L</span><span>&nbsp;:&nbsp;</span><span class="word">R</span><span>;</span></li><li><span>}</span></li></ol></div>
<div class="sh"><div class="bar">僅找出最小值</div><ol><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>&nbsp;=&nbsp;</span><span class="value">1000</span><span>;</span></li><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">logN</span><span>&nbsp;=&nbsp;</span><span class="word">ceil</span><span>(</span><span class="word">log2</span><span>(</span><span class="word">N</span><span>));</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">value</span><span>[</span><span class="word">N</span><span>];</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">t</span><span>[</span><span class="word">logN</span><span>][</span><span class="word">N</span><span>];&nbsp;</span><span class="comment">//&nbsp;t[i][j]儲存區間[j,&nbsp;j+2ⁱ-1]的最小值的索引值</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">construct</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="value">0</span><span>][</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="word">value</span><span>[</span><span class="word">i</span><span>];&nbsp;</span><span class="comment">//&nbsp;此處有異</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;減一、小於，可以改成小於等於。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">1</span><span>;&nbsp;(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">i</span><span>)&lt;=</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">j</span><span>+(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">i</span><span>)&lt;=</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">i</span><span>][</span><span class="word">j</span><span>]&nbsp;=&nbsp;</span><span class="word">min</span><span>(</span><span class="word">t</span><span>[</span><span class="word">i</span><span>-</span><span class="value">1</span><span>][</span><span class="word">j</span><span>],&nbsp;</span><span class="word">t</span><span>[</span><span class="word">i</span><span>-</span><span class="value">1</span><span>][</span><span class="word">j</span><span>+(</span><span class="value">1</span><span>&lt;&lt;(</span><span class="word">i</span><span>-</span><span class="value">1</span><span>))]);</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">query</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">a</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">b</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">p</span><span>&nbsp;=&nbsp;</span><span class="value">31</span><span>&nbsp;-&nbsp;</span><span class="word">__builtin_clz</span><span>(</span><span class="word">abs</span><span>(</span><span class="word">b</span><span>&nbsp;-&nbsp;</span><span class="word">a</span><span>)&nbsp;+&nbsp;</span><span class="value">1</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">min</span><span>(</span><span class="word">t</span><span>[</span><span class="word">p</span><span>][</span><span class="word">a</span><span>],&nbsp;</span><span class="word">t</span><span>[</span><span class="word">p</span><span>][</span><span class="word">b</span><span>-(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">p</span><span>)+</span><span class="value">1</span><span>]);</span></li><li><span>}</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/112/11235.html">11235</a></p>
<p class="t">推廣到高維度</p>
<p>這個資料結構可以推廣到高維度，建立方法是逐次處理各維度即可。以二維為例，先把矩陣切成一條一條的橫條，每個橫條都建立 1D Sparse Table ；然後以第一條橫條的表格為基礎，表格中的每一個子問題，都建立垂直方向的 1D Sparse Table ，如此便完成了二維的版本。</p>
<p>建立時間為 O(XlogX ⋅ YlogY ⋅ ...) ，建立空間為 O(XlogX ⋅ YlogY ⋅ ...) ，計算任意矩形區域最小值的時間是 O(2ᴰ) 。</p>
<div class="sh"><div class="bar">僅找出最小值</div><ol><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">X</span><span>&nbsp;=&nbsp;</span><span class="value">1000</span><span>,&nbsp;</span><span class="word">Y</span><span>&nbsp;=&nbsp;</span><span class="value">2000</span><span>;</span></li><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">logX</span><span>&nbsp;=&nbsp;</span><span class="word">ceil</span><span>(</span><span class="word">log</span><span>(</span><span class="word">X</span><span>)),&nbsp;</span><span class="word">logY</span><span>&nbsp;=&nbsp;</span><span class="word">ceil</span><span>(</span><span class="word">log</span><span>(</span><span class="word">Y</span><span>));</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">value</span><span>[</span><span class="word">X</span><span>][</span><span class="word">Y</span><span>];</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">t</span><span>[</span><span class="word">logX</span><span>][</span><span class="word">X</span><span>][</span><span class="word">logY</span><span>][</span><span class="word">Y</span><span>];</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">construct</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">X</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">j</span><span>&lt;</span><span class="word">Y</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="value">0</span><span>][</span><span class="word">i</span><span>][</span><span class="value">0</span><span>][</span><span class="word">j</span><span>]&nbsp;=&nbsp;</span><span class="word">value</span><span>[</span><span class="word">i</span><span>][</span><span class="word">j</span><span>];</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;先計算水平方向</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">k</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">k</span><span>&lt;</span><span class="word">Y</span><span>;&nbsp;++</span><span class="word">k</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">1</span><span>;&nbsp;(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">i</span><span>)&lt;=</span><span class="word">X</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">j</span><span>+(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">i</span><span>)&lt;=</span><span class="word">X</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="value">0</span><span>][</span><span class="word">k</span><span>][</span><span class="word">i</span><span>][</span><span class="word">j</span><span>]&nbsp;=&nbsp;</span><span class="word">min</span><span>(</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="value">0</span><span>][</span><span class="word">k</span><span>][</span><span class="word">i</span><span>-</span><span class="value">1</span><span>][</span><span class="word">j</span><span>],</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="value">0</span><span>][</span><span class="word">k</span><span>][</span><span class="word">i</span><span>-</span><span class="value">1</span><span>][</span><span class="word">j</span><span>+(</span><span class="value">1</span><span>&lt;&lt;(</span><span class="word">i</span><span>-</span><span class="value">1</span><span>))]</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;再整合垂直方向</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">i</span><span>)&lt;=</span><span class="word">X</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">j</span><span>&lt;</span><span class="word">X</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">p</span><span>=</span><span class="value">1</span><span>;&nbsp;(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">p</span><span>)&lt;=</span><span class="word">Y</span><span>;&nbsp;++</span><span class="word">p</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">q</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">q</span><span>+(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">p</span><span>)&lt;=</span><span class="word">Y</span><span>;&nbsp;++</span><span class="word">q</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">p</span><span>][</span><span class="word">q</span><span>][</span><span class="word">i</span><span>][</span><span class="word">j</span><span>]&nbsp;=&nbsp;</span><span class="word">min</span><span>(</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">p</span><span>-</span><span class="value">1</span><span>][</span><span class="word">q</span><span>][</span><span class="word">i</span><span>][</span><span class="word">j</span><span>],</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">p</span><span>-</span><span class="value">1</span><span>][</span><span class="word">q</span><span>+(</span><span class="value">1</span><span>&lt;&lt;(</span><span class="word">p</span><span>-</span><span class="value">1</span><span>))][</span><span class="word">i</span><span>][</span><span class="word">j</span><span>]</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="type">int</span><span>&nbsp;</span><span class="word">query</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">x1</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">x2</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y1</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y2</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">x</span><span>&nbsp;=&nbsp;</span><span class="value">31</span><span>&nbsp;-&nbsp;</span><span class="word">__builtin_clz</span><span>(</span><span class="word">abs</span><span>(</span><span class="word">x2</span><span>&nbsp;-&nbsp;</span><span class="word">x1</span><span>)&nbsp;+&nbsp;</span><span class="value">1</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y</span><span>&nbsp;=&nbsp;</span><span class="value">31</span><span>&nbsp;-&nbsp;</span><span class="word">__builtin_clz</span><span>(</span><span class="word">abs</span><span>(</span><span class="word">y2</span><span>&nbsp;-&nbsp;</span><span class="word">y1</span><span>)&nbsp;+&nbsp;</span><span class="value">1</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;四個位於角落的矩形，大小都是(1&lt;&lt;x)&nbsp;*&nbsp;(1&lt;&lt;y)。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">min</span><span>(</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">x</span><span>][</span><span class="word">x1</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;][</span><span class="word">y</span><span>][</span><span class="word">y1</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">x</span><span>][</span><span class="word">x2</span><span>-(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">x</span><span>)+</span><span class="value">1</span><span>][</span><span class="word">y</span><span>][</span><span class="word">y1</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;],</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">x</span><span>][</span><span class="word">x1</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;][</span><span class="word">y</span><span>][</span><span class="word">y2</span><span>-(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">y</span><span>)+</span><span class="value">1</span><span>],</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">t</span><span>[</span><span class="word">x</span><span>][</span><span class="word">x2</span><span>-(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">x</span><span>)+</span><span class="value">1</span><span>][</span><span class="word">y</span><span>][</span><span class="word">y2</span><span>-(</span><span class="value">1</span><span>&lt;&lt;</span><span class="word">y</span><span>)+</span><span class="value">1</span><span>]</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;);</span></li><li><span>}</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/112/11263.html">11263</a></p>

</div></div><div class="a" id="6"><div class="h">
<p class="b">Sequence 資料結構 : <br> Cartesian Tree</p>
</div><div class="c">
<p class="t">Cartesian Tree</p>
<p><a href="http://web.engr.illinois.edu/~jeffe/teaching/algorithms/notes/10-treaps.pdf"> http://web.engr.illinois.edu/~jeffe/teaching/algorithms/notes/10-treaps.pdf </a></p>
<p>Cartesian Tree 是一種 Treap ，根的數值小於左右子樹，根的索引值介於左右子樹。</p>
<p>以 online 方式建立，由左到右讀取陣列元素，每讀取一個元素，就建立一個節點。整棵樹剛好依照 DFS 順序來回遍歷一次。通常使用 stack 實作，確保 stack 的元素依序排好。</p>
<p class="t">All Nearest Smaller Values</p>
<p><a href="http://en.wikipedia.org/wiki/All_nearest_smaller_values"> http://en.wikipedia.org/wiki/All_nearest_smaller_values </a></p>
<p class="t">±1 Range Minimum Query</p>
<p>RMQ 問題，以 O(N) 時間建立 Cartesian Tree ，便化作 LCA 問題。</p>
<p>LCA 問題，以 O(N) 時間用 DFS 遍歷，記下到訪次序（作為索引值）、深度（作為元素值），便化作 ±1RMQ 問題。</p>
<p>±1RMQ 問題有著特殊的演算法，建立時間為 O(N) 、查詢時間為 O(1) ，到達理論下限。然而 ±1RMQ 規則複雜，實務上效率極差，此處不介紹，請讀者自行尋找資料。</p>
<p>RMQ 問題、 LCA 問題、 ±1RMQ 問題的時間複雜度皆相等，而且到達理論下限。也就是說這三個問題已經被徹底解決了。</p>

</div></div><div class="a" id="7"><div class="h">
<p class="b">Sequence 資料結構 : <br> Quicksort Tree</p>
</div><div class="c">
<p class="t">Quicksort Tree 【尚無正式名稱】</p>
<p><a href="http://yueyue1105.blog.163.com/blog/static/431117682010716111425892/" class="l"> http://yueyue1105.blog.163.com/blog/static/431117682010716111425892/ </a></p>
<p>top-down 建立。以中位數作為 pivot ，預先排序以求得中位數。</p>
<p>建立 O(NlogN) 、修改 O(logN) 、無法插入及刪除、查詢區間內第 k 名元素 O(logN) ，查詢區間內元素名次 O(logNlogN) 。</p>
<p class="t">Wavelet Tree</p>
<p>即是 Succinct Quicksort Tree 。</p>
<p><a href="http://alexbowe.com/wavelet-trees/"> http://alexbowe.com/wavelet-trees/ </a></p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="word">https</span><span>:</span><span class="comment">//bitbucket.org/MaskRay/rustsnippets/src/e543491ce3ec8c9af95b18cdb8449b7c35b9960b/succinct/uncompressed_wavelet_tree.rs</span></li></ol></div>

</div></div><div class="a" id="8"><div class="h">
<p class="b">Sequence 資料結構 : <br> Mergesort Tree</p>
</div><div class="c">
<p class="t">Mergesort Tree 【尚無正式名稱】</p>
<p><a href="http://yueyue1105.blog.163.com/blog/static/431117682010716111425892/" class="l"> http://yueyue1105.blog.163.com/blog/static/431117682010716111425892/ </a></p>
<p>bottom-up 建立。</p>
<p>建立 O(NlogN) 、修改 O(logN) 、無法插入及刪除、查詢區間內第 k 名元素 O(logNlogN) ，查詢區間內元素名次 O(logNlogN) 。</p>
</div></div><script src="./Sequence_files/h.js.下载"></script><div class="m" style="left: 0px;"><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/index.html">◀ Index</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Sequence.html#1">Sequence資料結構:<br>Array / List</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Sequence.html#2">Sequence資料結構:<br>Binary Search Tree</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Sequence.html#3">Sequence資料結構:<br>“Fake” Segment Tree</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Sequence.html#4">Sequence資料結構:<br>Binary Indexed Tree</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Sequence.html#5">Sequence資料結構:<br>Sparse Table</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Sequence.html#6">Sequence資料結構:<br>Cartesian Tree</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Sequence.html#7">Sequence資料結構:<br>Quicksort Tree</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Sequence.html#8">Sequence資料結構:<br>Mergesort Tree</a></div></div></body></html>