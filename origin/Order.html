
<!-- saved from url=(0046)http://www.csie.ntnu.edu.tw/~u91029/Order.html -->
<html lang="zh-TW"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="./Order_files/style.css">
<title>演算法筆記 - Order</title></head><body>
<div class="a" id="1"><div class="h">
<p class="b">排序資料結構 : <br> Search Tree 系列</p>
</div><div class="c">
<p class="t">Binary Search Tree</p>
<p>請先參考「<a href="http://www.csie.ntnu.edu.tw/~u91029/BinaryTree.html"> Binary Tree </a>」。</p>
<img src="./Order_files/SearchTree1.png">
<p>二元搜尋樹。置放大量數字並且進行排序的資料結構。原理是 Divide and Conquer ，樹根居中，左子樹較小或相等，右子樹較大，然後遞迴分割下去。</p>
<p>插入、刪除、搜尋的時間複雜度等同於二元搜尋樹的高度。資料可以動態增加和減少，二元搜尋樹的高度亦會變動，因此時間複雜度最差為 O(N) ，最佳為 O(logN) 。所有節點連成一線的時候是最差的，所有節點形成 perfect binary tree 是最佳的。</p>
<p>空間複雜度等同於節點數目，空間複雜度是 O(N) 。</p>
<img src="./Order_files/SearchTree2.png">
<p>尋找極小值、極大值，從樹根開始往左小孩走到底、往右小孩走到底就可以了。時間複雜度等同於二元搜尋樹的高度。</p>
<img src="./Order_files/SearchTree3.png">
<p>尋找次大節點，就先往右小孩走一步、再往左小孩走到底就可以了；如果一開始沒有右小孩，就往左上父親走到底，再往右上父親走一步就可以了。尋找次小節點，方法類似。時間複雜度等同於二元搜尋樹的高度。</p>
<img src="./Order_files/SearchTree4.png">
<p>樹葉可以額外建立線索（ Thread ），左小孩連往次小節點，右小孩連往次大節點，如此就能迅速地依照大小順序走訪元素，實作僅用迴圈即可、免用遞迴。建立線索不影響時間複雜度與空間複雜度。</p>
<p class="t">最佳二元搜尋樹（ Optimum Binary Search Tree ）</p>
<!--<img src="SearchTree4.png">-->
<p>如果二元搜尋樹的資料不會變動，則可以依照每個節點被搜尋到的次數（頻率），使用 Dynamic Programming 求得結構最佳的二元搜尋樹，藉此減少搜尋時間。建立時間為 O(N²) 。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/103/10304.html">10304</a></p>
<p class="t">擴充資訊（ Augmented Tree ）</p>
<img src="./Order_files/SearchTree5.png">
<p>二元搜尋樹的每個節點，可以擴充資訊，例如子樹的高度、節點總數、數字總和、數字最大值、數字最小值、 …… 。</p>
<p class="t">排名（ Ranking ）</p>
<p>二元搜尋樹雖然有排序的功效，但是卻沒有排名的功效。想要排名，就要在每個節點新增一個變數，記錄其子樹的節點個數。不影響時間複雜度與空間複雜度。</p>
<img src="./Order_files/SearchTree6.png">
<p>找到第 k 名的節點：方向從根往葉，取得左小孩的節點個數，判斷第 k 名位於左子樹還是右子樹。時間複雜度等同於二元搜尋樹的高度。</p>
<img src="./Order_files/SearchTree7.png">
<p>找到節點是第幾名：方向從葉往根，累計左子樹的節點個數，判斷當前節點是左小孩或右小孩以決定是否累計。時間複雜度等同於二元搜尋樹的高度。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/109/10909.html">10909</a></p>
<p class="t">二進位數字表示法</p>
<img src="./Order_files/SearchTree8.png">
<p>二進位數字一一對應到二元搜尋樹的節點。</p>
<p>如此就能以陣列實作二元搜尋樹。優點是程式碼簡潔，效率高，缺點是浪費記憶體空間、樹的高度受限制。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">left_child</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">index</span><span>)&nbsp;{</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">index</span><span>&nbsp;*&nbsp;</span><span class="value">2</span><span>;}</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">right_child</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">index</span><span>)&nbsp;{</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">index</span><span>&nbsp;*&nbsp;</span><span class="value">2</span><span>&nbsp;+&nbsp;</span><span class="value">1</span><span>;}</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">binary_tree</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">tree</span><span>[</span><span class="value">5</span><span>&nbsp;+&nbsp;</span><span class="value">1</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;tree[0]不使用，只有五個節點。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="string">"根為"</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="word">tree</span><span>[</span><span class="value">1</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="string">"根的左邊小孩是"</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="word">tree</span><span>[</span><span class="word">left_child</span><span>(</span><span class="value">1</span><span>)];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="string">"根的右邊小孩是"</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="word">tree</span><span>[</span><span class="word">right_child</span><span>(</span><span class="value">1</span><span>)];</span></li><li><span>}</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/7/712.html">712</a></p>
<p class="t">AVL Tree</p>
<p><a href="http://www.qmatica.com/DataStructures/Trees/AVL/AVLTree.html" class="l"> http://www.qmatica.com/DataStructures/Trees/AVL/AVLTree.html </a></p>
<p>平衡二元搜尋樹。樹上每個節點（每棵子樹），其左右兩子樹的高度差最多為一。此舉造成整棵樹的高度為 O(logN) ，讓各項操作穩定運行，不會產生忽快忽慢的極端現象。</p>
<img src="./Order_files/SearchTree9.png">
<p>每當插入節點，高度差超過一，就馬上運用右旋轉或左旋轉調整高度；旋轉一至兩次，就使整棵樹平衡。旋轉不影響排序。</p>
<p>找到最深、高度差超過一的節點（子樹），依據插入節點的路線，可分為四類情況。左左 / 右右：旋轉子樹樹根，立即平衡。左右 / 右左：先旋轉子樹樹根的左 / 右小孩，成為左左 / 右右，後續同前。</p>
<p>刪除節點則是反過來做。</p>
<img src="./Order_files/SearchTree10.png">
<p>插入、刪除、搜尋的時間複雜度為 O(logN) 。旋轉、平衡的時間複雜度是 O(1) ，至於空間複雜度仍是 O(N) 。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">struct</span><span>&nbsp;</span><span class="word">Node</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">Node</span><span>*&nbsp;</span><span class="word">l</span><span>,&nbsp;*</span><span class="word">r</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">h</span><span>,&nbsp;</span><span class="word">c</span><span>,&nbsp;</span><span class="word">key</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">Node</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">key</span><span>):&nbsp;</span><span class="word">l</span><span>(</span><span class="value">0</span><span>),&nbsp;</span><span class="word">r</span><span>(</span><span class="value">0</span><span>),&nbsp;</span><span class="word">h</span><span>(</span><span class="value">1</span><span>),&nbsp;</span><span class="word">c</span><span>(</span><span class="value">1</span><span>),&nbsp;</span><span class="word">key</span><span>(</span><span class="word">key</span><span>)&nbsp;{}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;</span><span class="word">update</span><span>()</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">h</span><span>&nbsp;=&nbsp;</span><span class="value">1</span><span>&nbsp;+&nbsp;</span><span class="word">max</span><span>(</span><span class="word">l</span><span>?</span><span class="word">l</span><span>-&gt;</span><span class="word">h</span><span>:</span><span class="value">0</span><span>,&nbsp;</span><span class="word">r</span><span>?</span><span class="word">r</span><span>-&gt;</span><span class="word">h</span><span>:</span><span class="value">0</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">c</span><span>&nbsp;=&nbsp;(</span><span class="word">l</span><span>?</span><span class="word">l</span><span>-&gt;</span><span class="word">c</span><span>:</span><span class="value">0</span><span>)&nbsp;+&nbsp;</span><span class="value">1</span><span>&nbsp;+&nbsp;(</span><span class="word">r</span><span>?</span><span class="word">r</span><span>-&gt;</span><span class="word">c</span><span>:</span><span class="value">0</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}&nbsp;*</span><span class="word">root</span><span>;</span></li><li>&nbsp;</li><li><span class="word">Node</span><span>*&nbsp;</span><span class="word">rL</span><span>(</span><span class="word">Node</span><span>*&nbsp;</span><span class="word">x</span><span>)&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;左旋轉</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">Node</span><span>*&nbsp;</span><span class="word">y</span><span>&nbsp;=&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>&nbsp;=&nbsp;</span><span class="word">y</span><span>-&gt;</span><span class="word">l</span><span>;&nbsp;</span><span class="word">y</span><span>-&gt;</span><span class="word">l</span><span>&nbsp;=&nbsp;</span><span class="word">x</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">update</span><span>();&nbsp;</span><span class="word">y</span><span>-&gt;</span><span class="word">update</span><span>();</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">y</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="word">Node</span><span>*&nbsp;</span><span class="word">rR</span><span>(</span><span class="word">Node</span><span>*&nbsp;</span><span class="word">x</span><span>)&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;右旋轉</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">Node</span><span>*&nbsp;</span><span class="word">y</span><span>&nbsp;=&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>&nbsp;=&nbsp;</span><span class="word">y</span><span>-&gt;</span><span class="word">r</span><span>;&nbsp;</span><span class="word">y</span><span>-&gt;</span><span class="word">r</span><span>&nbsp;=&nbsp;</span><span class="word">x</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">update</span><span>();&nbsp;</span><span class="word">y</span><span>-&gt;</span><span class="word">update</span><span>();</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">y</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;忘了做nil檢查，會當機。</span></li><li><span class="word">Node</span><span>*&nbsp;</span><span class="word">balance</span><span>(</span><span class="word">Node</span><span>*&nbsp;</span><span class="word">x</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">update</span><span>();</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>-&gt;</span><span class="word">h</span><span>&nbsp;&gt;&nbsp;</span><span class="value">1</span><span>&nbsp;+&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>-&gt;</span><span class="word">h</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>-&gt;</span><span class="word">l</span><span>-&gt;</span><span class="word">h</span><span>&nbsp;&lt;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>-&gt;</span><span class="word">r</span><span>-&gt;</span><span class="word">h</span><span>)&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>&nbsp;=&nbsp;</span><span class="word">rL</span><span>(</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>&nbsp;=&nbsp;</span><span class="word">rR</span><span>(</span><span class="word">x</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>-&gt;</span><span class="word">h</span><span>&nbsp;&gt;&nbsp;</span><span class="value">1</span><span>&nbsp;+&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>-&gt;</span><span class="word">h</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>-&gt;</span><span class="word">r</span><span>-&gt;</span><span class="word">h</span><span>&nbsp;&lt;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>-&gt;</span><span class="word">l</span><span>-&gt;</span><span class="word">h</span><span>)&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>&nbsp;=&nbsp;</span><span class="word">rR</span><span>(</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>&nbsp;=&nbsp;</span><span class="word">rL</span><span>(</span><span class="word">x</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">x</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="word">Node</span><span>*&nbsp;</span><span class="word">insert</span><span>(</span><span class="word">Node</span><span>*&nbsp;</span><span class="word">x</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">key</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">x</span><span>&nbsp;==&nbsp;</span><span class="value">0</span><span>)&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="keyword">new</span><span>&nbsp;</span><span class="word">Node</span><span>(</span><span class="word">key</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">key</span><span>&nbsp;&lt;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">key</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>&nbsp;=&nbsp;</span><span class="word">insert</span><span>(</span><span class="word">x</span><span>-&gt;</span><span class="word">l</span><span>,&nbsp;</span><span class="word">key</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>&nbsp;=&nbsp;</span><span class="word">insert</span><span>(</span><span class="word">x</span><span>-&gt;</span><span class="word">r</span><span>,&nbsp;</span><span class="word">key</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">balance</span><span>(</span><span class="word">x</span><span>);</span></li><li><span>}</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/116/11688.html">11688</a></p>
<p class="t">Red-Black Tree</p>
<p>紅黑樹的功效等同平衡二元搜尋樹，但是效率更勝一籌。</p>
<p><a href="http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf"> http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf </a></p>
<p>可以直接使用 STL 的 set 、 map ，但是沒有排名功能。</p>
<p class="t">Splay Tree</p>
<img src="./Order_files/SearchTree11.png">
<p>splay 是按照規則，把一個節點不斷雙旋至根。插入、刪除之後立即 splay ，儘管樹沒有完全平衡，插入、刪除的均攤時間複雜度是 O(logN) 。</p>
<p>splay 改為單旋，均攤時間複雜度並非 O(logN) ，卻是個不錯的偷懶方式。</p>
<p>運用 splay 拆接子樹，時間複雜度是 O(logN) ，是主要特色。</p>
<div class="sh"><div class="bar">不支援刪除的實作方式</div><ol><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">V</span><span>&nbsp;=&nbsp;</span><span class="value">10000</span><span>+</span><span class="value">1</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;第零格作為nil</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">value</span><span>[</span><span class="word">V</span><span>];</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">parent</span><span>[</span><span class="word">V</span><span>],&nbsp;</span><span class="word">child</span><span>[</span><span class="word">V</span><span>][</span><span class="value">2</span><span>];&nbsp;</span><span class="comment">//&nbsp;父親、左右小孩</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">height</span><span>[</span><span class="word">V</span><span>],&nbsp;</span><span class="word">size</span><span>[</span><span class="word">V</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;子樹高度、子樹大小</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">T</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>,&nbsp;</span><span class="word">root</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;節點數、根</span></li><li>&nbsp;</li><li><span class="macro">#define&nbsp;l(i)&nbsp;child[i][0]</span></li><li><span class="macro">#define&nbsp;r(i)&nbsp;child[i][1]</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">update</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">height</span><span>[</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="value">1</span><span>&nbsp;+&nbsp;</span><span class="word">max</span><span>(</span><span class="word">height</span><span>[</span><span class="word">l</span><span>(</span><span class="word">i</span><span>)],&nbsp;</span><span class="word">height</span><span>[</span><span class="word">r</span><span>(</span><span class="word">i</span><span>)]);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">size</span><span>[</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="value">1</span><span>&nbsp;+&nbsp;</span><span class="word">size</span><span>[</span><span class="word">l</span><span>(</span><span class="word">i</span><span>)]&nbsp;+&nbsp;</span><span class="word">size</span><span>[</span><span class="word">r</span><span>(</span><span class="word">i</span><span>)];</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;判斷自己是左小孩或右小孩</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">side</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">r</span><span>(</span><span class="word">parent</span><span>[</span><span class="word">i</span><span>])&nbsp;==&nbsp;</span><span class="word">i</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;轉吧轉吧</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">rotate</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">x</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">r</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">y</span><span>&nbsp;=&nbsp;</span><span class="word">parent</span><span>[</span><span class="word">x</span><span>];</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">parent</span><span>[</span><span class="word">y</span><span>])&nbsp;</span><span class="word">child</span><span>[</span><span class="word">parent</span><span>[</span><span class="word">y</span><span>]][</span><span class="word">side</span><span>(</span><span class="word">y</span><span>)]&nbsp;=&nbsp;</span><span class="word">x</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">child</span><span>[</span><span class="word">y</span><span>][</span><span class="word">r</span><span>]&nbsp;=&nbsp;</span><span class="word">child</span><span>[</span><span class="word">x</span><span>][!</span><span class="word">r</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">child</span><span>[</span><span class="word">x</span><span>][!</span><span class="word">r</span><span>]&nbsp;=&nbsp;</span><span class="word">y</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">parent</span><span>[</span><span class="word">x</span><span>]&nbsp;=&nbsp;</span><span class="word">parent</span><span>[</span><span class="word">y</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">child</span><span>[</span><span class="word">y</span><span>][</span><span class="word">r</span><span>])&nbsp;</span><span class="word">parent</span><span>[</span><span class="word">child</span><span>[</span><span class="word">y</span><span>][</span><span class="word">r</span><span>]]&nbsp;=&nbsp;</span><span class="word">y</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">parent</span><span>[</span><span class="word">y</span><span>]&nbsp;=&nbsp;</span><span class="word">x</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">update</span><span>(</span><span class="word">y</span><span>);</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">splay</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">x</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">y</span><span>&nbsp;=&nbsp;</span><span class="word">parent</span><span>[</span><span class="word">x</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">rx</span><span>&nbsp;=&nbsp;</span><span class="word">side</span><span>(</span><span class="word">x</span><span>),&nbsp;</span><span class="word">ry</span><span>&nbsp;=&nbsp;</span><span class="word">side</span><span>(</span><span class="word">y</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(!</span><span class="word">parent</span><span>[</span><span class="word">y</span><span>])&nbsp;</span><span class="word">rotate</span><span>(</span><span class="word">x</span><span>,&nbsp;</span><span class="word">rx</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">rx</span><span>&nbsp;==&nbsp;</span><span class="word">ry</span><span>)&nbsp;</span><span class="word">rotate</span><span>(</span><span class="word">y</span><span>,&nbsp;</span><span class="word">ry</span><span>),&nbsp;</span><span class="word">rotate</span><span>(</span><span class="word">x</span><span>,&nbsp;</span><span class="word">rx</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="word">rotate</span><span>(</span><span class="word">x</span><span>,&nbsp;</span><span class="word">rx</span><span>),&nbsp;</span><span class="word">rotate</span><span>(</span><span class="word">x</span><span>,&nbsp;</span><span class="word">ry</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">update</span><span>(</span><span class="word">x</span><span>);</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;建立節點</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">create</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;++</span><span class="word">T</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">l</span><span>(</span><span class="word">i</span><span>)&nbsp;=&nbsp;</span><span class="word">r</span><span>(</span><span class="word">i</span><span>)&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">height</span><span>[</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="word">size</span><span>[</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">value</span><span>[</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="word">n</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">i</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;插入</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">insert</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(!</span><span class="word">root</span><span>)&nbsp;{</span><span class="word">root</span><span>&nbsp;=&nbsp;</span><span class="word">create</span><span>(</span><span class="word">n</span><span>);&nbsp;</span><span class="keyword">return</span><span>;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;</span><span class="word">root</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>&nbsp;=&nbsp;</span><span class="word">child</span><span>[</span><span class="word">i</span><span>][</span><span class="word">n</span><span>&nbsp;&gt;&nbsp;</span><span class="word">value</span><span>[</span><span class="word">i</span><span>]])&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;</span><span class="word">j</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>&nbsp;=&nbsp;</span><span class="word">create</span><span>(</span><span class="word">n</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">parent</span><span>[</span><span class="word">j</span><span>]&nbsp;=&nbsp;</span><span class="word">i</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">child</span><span>[</span><span class="word">i</span><span>][</span><span class="word">n</span><span>&nbsp;&gt;&nbsp;</span><span class="word">value</span><span>[</span><span class="word">i</span><span>]]&nbsp;=&nbsp;</span><span class="word">j</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">splay</span><span>(</span><span class="word">j</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">root</span><span>&nbsp;=&nbsp;</span><span class="word">j</span><span>;</span></li><li><span>}</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">splay_tree</span><span>()</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">cin</span><span>&nbsp;&gt;&gt;&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">insert</span><span>(</span><span class="word">n</span><span>);</span></li><li><span>}</span></li></ol></div>

</div></div><div class="a" id="2"><div class="h">
<p class="b">排序資料結構 : <br> Multi-way Search Tree 系列</p>
</div><div class="c">
<p class="t">B-Tree</p>
<img src="./Order_files/SearchTree12.png">
<p>Binary Tree 再進化！一個節點改為儲存大量數字和分枝，以符合傳輸通道大小、減少傳輸次數。適用「每次讀取需要很多準備時間、一次可以讀取一連串資料」的設備，例如硬碟、網路資料庫。</p>
<p>一筆異地資料，存取時間約是計算時間的一千倍！此時我們關心存取時間（存取次數），不太關心計算時間（時間複雜度）。儘管 B-Tree 的搜尋、插入、刪除遠比 Binary Tree 冗長，但是 B-Tree 存取節點的次數較少！是 External Memory Algorithm 的經典範例。</p>
<p>網路已有詳細的教學和動畫，請讀者自行搜尋。</p>
<pre>一、一個節點，可儲存m個分枝、m-1個數字。
二、一個節點，數字由小到大，循序儲存。
三、所有樹葉，位於同一層。
四、小孩數量等於數字數量加一。（排除樹葉）
五、小孩數量上下限是[ceil(m/2) , m]。（排除樹葉）
六、樹根不考慮小孩數量上下限。
</pre>
<p>插入、刪除過程繁複，動用許多節點。後來又發明了 B⁺-Tree 與 B*-Tree ，盡可能直接編輯鄰近節點，避免新增、刪除、搬移節點。</p>
<p class="t">(a,b)-Tree</p>
<p>最少 a 個小孩，最多 b 個小孩。詳細內容請自行搜尋。</p>

</div></div><div class="a" id="3"><div class="h">
<p class="b">排序資料結構 : <br> Skip Lists</p>
</div><div class="c">
<p class="t">Skip Lists</p>
<p><a href="http://en.wikipedia.org/wiki/Skip_list"> http://en.wikipedia.org/wiki/Skip_list </a></p>
<p>置放大量數字並進行排序的資料結構。不用樹狀結構，而改用高度不同的 List 來連接資料。資料結構在概念上可以表示成 Left Child-Right Sibling Binary Tree 的模式。是 Cache-oblivious Algorithm 的經典範例。</p>
<p>時間複雜度與空間複雜度與 Binary Search Tree 皆相同，但是實際運作效率比 Binary Search Tree 還要好。</p>

</div></div><div class="a" id="4"><div class="h">
<p class="b">極值資料結構 : <br> Heap 系列</p>
</div><div class="c">
<p class="t">Priority Queue</p>
<p>置放大量數字，可以隨時添加數字、隨時取出極值（最小值、最大值，只能選一種）的資料結構，泛稱 Priority Queue 。</p>
<p>泛稱是用來凸顯資料結構的功能。有了這樣的泛稱，當遇到的問題隱含著 queue 與 sort 的概念，就能直覺聯想到 Priority Queue 資料結構，而不會被 Heap 、 Search Tree 這種不直覺的名稱困住了思考。</p>
<p class="t">極值是排序的特例</p>
<pre>Heap    Search Tree
-------------------------
push    insert
pop     extremum + delete
peek    extremum
merge   merge
</pre>
<p>Heap 的每一項操作，都能用 Search Tree 兜出來，時間複雜度完全一樣，唯一的例外是： Heap 預先偷看極值，僅需 O(1) 時間； Search Tree 則需 O(logN) 時間來搜尋極值。</p>
<p>如果在 push 和 pop 之時，隨時記錄極值， Search Tree 還是能快速偷看極值。</p>
<p class="t">Binary Heap</p>
<p>二元樹，樹根的數字，總是小於等於左右小孩的數字。</p>
<p>插入、刪除、求極值的時間複雜度為 O(logN) 。</p>
<p>可以直接使用 STL 的 priority_queue 。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/5/501.html">501</a> <a href="http://uva.onlinejudge.org/external/105/10587.html">10587</a> <a href="http://uva.onlinejudge.org/external/119/11997.html">11997</a></p>
<p class="t">Binomial Heap</p>
<p>遞迴結合多個高度不同的 Binomial Tree ，以抽象化的角度來看像是一個二進位系統。兩個 Binomial Heap 在結合的時候，原理就像是在做二進位加法一樣，因而得此名。</p>
<p class="t">Fibonacci Heap</p>
<p>規則極其詭異，重點在於它有一個特殊功能叫做 decrease key ，可以搜尋數字，並且還可以減少該數字，時間複雜度均攤之後僅有 O(1) 。另外，插入的時間複雜度均攤之後僅有 O(1) 。</p>
<p>僅有理論上的價值，沒有實務上的價值。</p>
<p class="t">Quake Heap</p>
<p>跟 Fibonacci Heap 功效相同，據說簡單很多。因為課本沒教而乏人問津。</p>
<p><a href="https://cs.uwaterloo.ca/~tmchan/heap.ps"> https://cs.uwaterloo.ca/~tmchan/heap.ps </a></p>
<p class="t">Treap</p>
<p>Binary Search Tree 與 Binary Heap 進行合體術。</p>
<p>令數字擁有額外的次序，同時具有「排次序」與「求極值」的功能。樹根的次序介於左右子樹，樹根的數字小於等於左右子樹。</p>
<p>具備排名功效的 Binary Search Tree ，可以用來代替 Treap 。</p>

</div></div><div class="a" id="5"><div class="h">
<p class="b">極值資料結構 : <br> van Emde Boas Tree</p>
</div><div class="c">
<p class="t">van Emde Boas Tree （ vEB Tree ）</p>
<p>置放大量正整數（與零）的資料結構，並且可以作為 Double Ended Priority Queue ，同時求得最小值與最大值。</p>
<p>利用 Divide and Conquer ，將 0 到 K-1 的整數分為 sqrt(K) 個區塊，每個區塊的範圍大小為 sqrt(K) ，接著各區塊各自遞迴下去。</p>
<p>以另一個角度來看，就是把一個整數從中間切開，成為高位數字部份和低位數字部份，把高位數字抽取出來，作為索引值，找出對應的陣列格子，並遞迴下去以儲存低位數字。跟「<a href="http://www.csie.ntnu.edu.tw/~u91029/String.html"> Trie </a>」有點像。</p>
<p>每次搜尋、插入、刪除為 O(loglogK) ，總時間複雜度為 O(NloglogK) ，其中 N 為正整數個數， K 為這些正整數的最大值。
</p><p>速度是快了那麼一點，然而缺點是記憶體用很兇，空間複雜度為 O(K) 。【待補分析】</p>
<p>其實我們也可以使用 Counting Sort 來記錄正整數，速度還比 vEB Tree 快，只不過 Counting Sort 不能動態排序罷了。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">struct</span><span>&nbsp;</span><span class="word">vEB_Tree</span><span>&nbsp;</span><span class="comment">//&nbsp;[0,&nbsp;K-1]&nbsp;have&nbsp;m&nbsp;digits&nbsp;in&nbsp;binary</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">digit</span><span>;&nbsp;&nbsp;</span><span class="comment">//&nbsp;store&nbsp;m。或者記錄陣列有多大（遞迴有多深）。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">vEB_Tree</span><span>*&nbsp;</span><span class="word">lower</span><span>[</span><span class="word">possibility</span><span>&nbsp;</span><span class="word">of</span><span>&nbsp;</span><span class="word">m</span><span>/</span><span class="value">2</span><span>&nbsp;</span><span class="word">digits</span><span>];</span></li><li><span>};</span></li></ol></div>
<p>若要作為 Double Ended Priority Queue ，則在每個節點加上兩個變數，記錄該子樹目前擁有的數字的大小範圍。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">struct</span><span>&nbsp;</span><span class="word">vEB_Tree</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">digit</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">vEB_Tree</span><span>*&nbsp;</span><span class="word">lower</span><span>[</span><span class="word">possibility</span><span>&nbsp;</span><span class="word">of</span><span>&nbsp;</span><span class="word">m</span><span>/</span><span class="value">2</span><span>&nbsp;</span><span class="word">digits</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">min</span><span>,&nbsp;</span><span class="word">max</span><span>;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;子樹目前擁有的數字們，最大值與最小值。</span></li><li><span>};</span></li></ol></div>
</div></div><script src="./Order_files/h.js.下载"></script><div class="m" style="left: 0px;"><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/index.html">◀ Index</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Order.html#1">排序資料結構:<br>Search Tree系列</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Order.html#2">排序資料結構:<br>Multi-way Search Tree系列</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Order.html#3">排序資料結構:<br>Skip Lists</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Order.html#4">極值資料結構:<br>Heap系列</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/Order.html#5">極值資料結構:<br>van Emde Boas Tree</a></div></div></body></html>