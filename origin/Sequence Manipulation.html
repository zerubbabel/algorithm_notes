
<!-- saved from url=(0061)http://www.csie.ntnu.edu.tw/~u91029/SequenceManipulation.html -->
<html lang="zh-TW"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="./Sequence Manipulation_files/style.css">
<title>演算法筆記 - Sequence Manipulation</title><style>.G15jkyanO{width:380px;text-align:center;font-family:Arial Unicode MS, Arial, sans-serif;}.G15jkyanGB{width:50px;}.G15jkyanFB{width:370px;height:120px;margin-left:auto;margin-right:auto;margin-bottom:5px;border:1px solid black;text-align:left;background:#e0e0e0;font-size:small;}.G15jkyanFB ul{padding-left:25px;padding-right:5px;margin-top:10px;}.G15jkyanFB li{line-height:20px;}.G15jkyanAB{border:solid 1px black;width:370px;height:350px;margin-left:auto;margin-right:auto;margin-bottom:5px;font-size:80%;}.G15jkyanJ{width:350px;margin-left:auto;margin-right:auto;}.G15jkyanBB{background-color:yellow;}.G15jkyanP{background-color:lime;}.G15jkyanCB{text-align:center;}.G15jkyanDB{border-top:1px solid;border-right:1px solid;border-bottom:1px solid;border-left:0 solid;width:25px;height:27px;font-size:medium;}.G15jkyanEB{border-left:1px solid;}.G15jkyanK{border-top-width:3px;border-bottom-width:3px;height:25px;}.G15jkyanM{border-left-width:3px;width:23px;}.G15jkyanN{border-right-width:3px;width:23px;}.G15jkyanL{border-left-width:3px;border-right-width:3px;width:19px;}</style></head><body>
<div class="a" id="1"><div class="h">
<p class="b">Sort</p>
<p class="w">父之齒隨行，兄之齒鴈行，朋友不相踰。《禮記．王制》</p>
</div><div class="c">
<p class="t">Sort</p>
<p>排序。把一群數字由小到大排好。</p>
<p>實際要做排序，有兩個方向，一是將數字放入循序性資料結構（例如 array 與 list ），然後執行下述其中一種排序演算法。二是使用有排序功效的資料結構，例如 binary heap 、 binary search tree ，將數字整個倒進去、整個倒出來即排序完畢。</p>
<pre>               | best     average  worst    | extra | stable
               | case     case     case     | space |
---------------+----------------------------+-------+--------
brute force    | O(NR)    O(NR)    O(NR)    | O(N)  | O
selection sort | O(NN)    O(NN)    O(NN)    | O(1)  | X
bubble sort    | O(N)     O(NN)    O(NN)    | O(1)  | O
gnome sort     | O(N)     O(NN)    O(NN)    | O(1)  | O
insertion sort | O(N)     O(NN)    O(NN)    | O(1)  | O
Shell sort     | O(NN)    O(NN)    O(NN)    | O(1)  | X
merge sort     | O(NlogN) O(NlogN) O(NlogN) | O(N)  | O
quicksort      | O(NlogN) O(NlogN) O(NN)    | O(N)  | X
heapsort       | O(NlogN) O(NlogN) O(NlogN) | O(1)  | X
counting sort  | O(N+R)   O(N+R)   O(N+R)   | O(R)  | O
bucket sort    | O(N+B+?) O(N+B+?) O(N+B+?) | O(B)  | X
radix sort     | O(ND)    O(ND)    O(ND)    | O(D)  | O
</pre>
<p>除了數字可以排序之外，事實上字元也可以排序，因為電腦中的字元就是數字（請參照 ASCII 表）。指標也可以排序，因為指標就是記憶體位址也就是數字。一般資料也可以排序，只要資料裡的某個特定欄位是數字，這個欄位被稱作鍵值（ key ）。</p>
<p class="t">排序原理</p>
<p>排序的基本原理，當今只有兩種，一是對調（數字是實數），二是放置（數字必須是整數）。</p>
<p>純粹透過對調來排序，已證明出數字兩兩比較的次數是 Ω(NlogN) ，不可能更少了，當今也已經有了到達下限的排序演算法，例如 merge sort 。同時透過對調與放置來排序，則可以打破方才的下限，例如 flashsort 。</p>
<p>純粹透過放置來排序，需要額外的記憶體空間來放置數字。時間複雜度通常是數字數量加上記憶體用量，效率相當好，只可惜只能處理整數，例如 counting sort 。</p>
<p class="t">暴力搜尋</p>
<p>依序枚舉每一個整數，看看陣列裡頭有沒有。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">brute_force</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">max_value</span><span>&nbsp;=&nbsp;-</span><span class="value">1e9</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">min_value</span><span>&nbsp;=&nbsp;</span><span class="value">1e9</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">max_value</span><span>&nbsp;=&nbsp;</span><span class="word">max</span><span>(</span><span class="word">max_value</span><span>,&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>]);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">min_value</span><span>&nbsp;=&nbsp;</span><span class="word">min</span><span>(</span><span class="word">min_value</span><span>,&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>]);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="word">min_value</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;=</span><span class="word">max_value</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;看看陣列裡面有沒有</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">j</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]&nbsp;==&nbsp;</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">cout</span><span>&nbsp;&lt;&lt;&nbsp;</span><span class="word">i</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li></ol></div>
<p>令陣列最小值為 A ，最大值為 B 。令 A 和 B 之間的整數有 R 個， R = B-A+1 。時間複雜度為 O(RN) 。</p>
<p class="t">Selection Sort</p>
<p>掃描一遍所有數字，找到最小值，挪至陣列左端。遞迴處理尚未排序的 N-1 個元素。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">selection_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)&nbsp;</span><span class="comment">//&nbsp;N改為N-1更精準</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;從尚未排序的數字當中，找出最小的數字。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;（它也是全部數字當中第i小的數字。）</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">min_index</span><span>&nbsp;=&nbsp;</span><span class="word">i</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="word">i</span><span>+</span><span class="value">1</span><span>;&nbsp;</span><span class="word">j</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]&nbsp;&lt;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">min_index</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">min_index</span><span>&nbsp;=&nbsp;</span><span class="word">j</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;把第i小的數字，放在第i個位置。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[</span><span class="word">i</span><span>],&nbsp;</span><span class="word">array</span><span>[</span><span class="word">min_index</span><span>]);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li></ol></div>
<p class="t">Bubble Sort</p>
<p>由左到右，相鄰兩兩比較，較大者往右挪，最後最大值會出現在陣列右端。遞迴處理尚未排序的 N-1 個元素。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">bubble_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)&nbsp;</span><span class="comment">//&nbsp;N改為N-1更精準</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">j</span><span>&lt;</span><span class="word">N</span><span>-</span><span class="word">i</span><span>-</span><span class="value">1</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]&nbsp;&gt;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>+</span><span class="value">1</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[</span><span class="word">j</span><span>],&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>+</span><span class="value">1</span><span>]);</span></li><li><span>}</span></li></ol></div>
<p>稍做改良：一旦排序好，便趕快結束。當資料很亂時，這麼做效益不彰。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">bubble_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)&nbsp;</span><span class="comment">//&nbsp;N改為N-1更精準</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">bool</span><span>&nbsp;</span><span class="word">sorted</span><span>&nbsp;=&nbsp;</span><span class="keyword">true</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>-</span><span class="word">j</span><span>-</span><span class="value">1</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]&nbsp;&gt;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>+</span><span class="value">1</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[</span><span class="word">j</span><span>],&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>+</span><span class="value">1</span><span>]);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">sorted</span><span>&nbsp;=&nbsp;</span><span class="keyword">false</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">sorted</span><span>)&nbsp;</span><span class="keyword">return</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li></ol></div>
<p class="t">Gnome Sort</p>
<p>原理和 Bubble Sort 相同，但是兩兩比較的先後次序有所改變。特色是程式碼只有一個迴圈，結構簡單。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">gnome_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">i</span><span>&nbsp;==&nbsp;</span><span class="value">0</span><span>&nbsp;||&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>-</span><span class="value">1</span><span>]&nbsp;&lt;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">i</span><span>++;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[</span><span class="word">i</span><span>-</span><span class="value">1</span><span>],&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>]);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">i</span><span>--;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li></ol></div>
<p class="t">Insertion Sort</p>
<p>由左到右，逐一把數字插入到目前已排序的陣列當中。需將大量數字往右挪，以騰出空間插入數字。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">insertion_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">2</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">pivot</span><span>&nbsp;=&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>];</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="word">j</span><span>=</span><span class="word">i</span><span>-</span><span class="value">1</span><span>;&nbsp;</span><span class="word">j</span><span>&gt;=</span><span class="value">0</span><span>;&nbsp;--</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">pivot</span><span>&nbsp;&lt;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>+</span><span class="value">1</span><span>]&nbsp;=&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>];&nbsp;&nbsp;</span><span class="comment">//&nbsp;先行往右挪</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">break</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>+</span><span class="value">1</span><span>]&nbsp;=&nbsp;</span><span class="word">pivot</span><span>;&nbsp;</span><span class="comment">//&nbsp;插入</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li></ol></div>
<p>資料結構如果是 array ，可以使用 Binary Search 快速找到插入點；但是很不幸的，插入時還是要挪動整塊記憶體。</p>
<p>資料結構如果是 list ，就無法使用 Binary Search 得到插入點；但是很幸運地，插入時不必挪動整塊記憶體。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/101/10107.html">10107</a></p>
<p class="t">Shell Sort</p>
<p>Shell 是一個人名，是發明這個演算法的人，不是殼的意思。</p>
<p>運用 Scaling Method ：以固定間隔取得數字做為一組，各組各自做 Insertion Sort ；然後減少間隔大小，重複上述動作。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">shell_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">gap</span><span>&nbsp;=&nbsp;</span><span class="word">N</span><span>/</span><span class="value">2</span><span>;&nbsp;</span><span class="word">gap</span><span>&nbsp;&gt;&nbsp;</span><span class="value">0</span><span>;&nbsp;</span><span class="word">gap</span><span>&nbsp;/=&nbsp;</span><span class="value">2</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;</span><span class="word">gap</span><span>;&nbsp;</span><span class="word">i</span><span>&nbsp;&lt;&nbsp;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>&nbsp;=&nbsp;</span><span class="word">i</span><span>-</span><span class="word">gap</span><span>;&nbsp;</span><span class="word">j</span><span>&nbsp;&gt;=&nbsp;</span><span class="value">0</span><span>&nbsp;&amp;&amp;&nbsp;</span><span class="word">v</span><span>[</span><span class="word">j</span><span>]&nbsp;&gt;&nbsp;</span><span class="word">v</span><span>[</span><span class="word">j</span><span>+</span><span class="word">gap</span><span>];&nbsp;</span><span class="word">j</span><span>&nbsp;-=&nbsp;</span><span class="word">gap</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">v</span><span>[</span><span class="word">j</span><span>],&nbsp;</span><span class="word">v</span><span>[</span><span class="word">j</span><span>+</span><span class="word">gap</span><span>]);</span></li><li><span>}</span></li></ol></div>
<p class="t">Merge Sort</p>
<p>運用 Divide and Conquer ： Divide 是陣列分兩半； Conquer 是兩半分別排序； Combine 是兩半各自排序好的陣列，弄成一條排序好的陣列。</p>
<p>可以直接使用 STL 的 stable_sort() 。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/108/10810.html">10810</a></p>
<p class="t">Quicksort</p>
<p>運用 Divide and Conquer ： Divide 是選定 pivot ，把 pivot 挪到陣列邊緣，然後把陣列分成大的一邊和小的一邊； Conquer 是兩邊分別排序； Combine 不做任何事。</p>
<p>可以任選一個數字當作 pivot ，排序結果皆正確。要讓 Quicksort 達到最佳效率，就是每次選中的 pivot ，都剛好可以把陣列分成兩等份，如此一來時間複雜度是 O(NlogN) ，這是帶點運氣成份的。幸運的是，即便把陣列分成數量懸殊的兩半，即便是 1000000:1 ，只要有個比例，時間複雜度還是 O(NlogN) 。</p>
<p>固定選擇最後一個數字當作 pivot ，也有機會把陣列分成兩等份。但是這卻產生一個古怪的現象：遇到已經排序的陣列，卻會變成每次都沒有分到，時間複雜度變成 O(N²) ，超級慢。</p>
<p>結果導致 Quicksort 有時快、有時卻很慢，遇到幾乎排序好的陣列，更是慢到吐血。時快時慢，該快不快，那不是很莫名其妙嗎？</p>
<p>為了避免這種情況，可以每次都用亂數指定 pivot ，這樣不管給定陣列是有排序的或是沒排序的，兩等份的機會都一樣多，如此就比較不會出現前述的古怪情形。不過這又衍生出一個問題，只是想做個排序，卻還得載入亂數模組，耗損系統資源、拖慢系統速度，帶來了新的壞處。</p>
<p>最後大家捨棄亂數，轉而構思一些簡單小技巧，讓選出來的 pivot 儘可能把陣列分成兩等分。例如 Java 的 Quicksort 是把陣列切成前中後三段，拿這三段中央的數字，三個數字的中位數當作 pivot 。這便是一個簡單實用的小技巧。</p>
<div class="sh"><div class="bar">蠟燭兩頭燒</div><ol><li><span class="comment">//&nbsp;sort&nbsp;interval&nbsp;[left,&nbsp;right]</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">quick_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">left</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">right</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">left</span><span>&nbsp;&lt;&nbsp;</span><span class="word">right</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;divide&nbsp;(partition)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">pivot</span><span>&nbsp;=&nbsp;</span><span class="word">array</span><span>[(</span><span class="word">left</span><span>+</span><span class="word">right</span><span>)/</span><span class="value">2</span><span>];&nbsp;&nbsp;</span><span class="comment">//&nbsp;可以隨便選</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;</span><span class="word">left</span><span>&nbsp;-&nbsp;</span><span class="value">1</span><span>,&nbsp;</span><span class="word">j</span><span>&nbsp;=&nbsp;</span><span class="word">right</span><span>&nbsp;+&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">i</span><span>&nbsp;&lt;&nbsp;</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">do</span><span>&nbsp;++</span><span class="word">i</span><span>;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">i</span><span>]&nbsp;&lt;&nbsp;</span><span class="word">pivot</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">do</span><span>&nbsp;--</span><span class="word">j</span><span>;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]&nbsp;&gt;&nbsp;</span><span class="word">pivot</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">i</span><span>&nbsp;&lt;&nbsp;</span><span class="word">j</span><span>)&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[</span><span class="word">i</span><span>],&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;then&nbsp;conquer</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">quick_sort</span><span>(</span><span class="word">array</span><span>,&nbsp;</span><span class="word">left</span><span>,&nbsp;</span><span class="word">i</span><span>-</span><span class="value">1</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">quick_sort</span><span>(</span><span class="word">array</span><span>,&nbsp;</span><span class="word">j</span><span>+</span><span class="value">1</span><span>,&nbsp;</span><span class="word">right</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;no&nbsp;need&nbsp;to&nbsp;combine&nbsp;sub-solutions</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li></ol></div>
<div class="sh"><div class="bar">蠟燭燒一頭</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">quick_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">left</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">right</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">left</span><span>&nbsp;&lt;&nbsp;</span><span class="word">right</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;divide&nbsp;(partition)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">pivot</span><span>&nbsp;=&nbsp;</span><span class="word">array</span><span>[(</span><span class="word">left</span><span>+</span><span class="word">right</span><span>)/</span><span class="value">2</span><span>];&nbsp;&nbsp;</span><span class="comment">//&nbsp;可以隨便選</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[</span><span class="word">right</span><span>],&nbsp;</span><span class="word">array</span><span>[(</span><span class="word">left</span><span>+</span><span class="word">right</span><span>)/</span><span class="value">2</span><span>]);&nbsp;&nbsp;</span><span class="comment">//&nbsp;換到最右邊</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;</span><span class="word">left</span><span>,&nbsp;</span><span class="word">j</span><span>&nbsp;=&nbsp;</span><span class="word">left</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(;&nbsp;</span><span class="word">j</span><span>&nbsp;&lt;&nbsp;</span><span class="word">right</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]&nbsp;&lt;=&nbsp;</span><span class="word">pivot</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">i</span><span>&nbsp;&lt;&nbsp;</span><span class="word">j</span><span>)&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[</span><span class="word">i</span><span>],&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]);&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;不加if也可以</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;</span><span class="word">i</span><span>&nbsp;+&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">i</span><span>&nbsp;&lt;&nbsp;</span><span class="word">right</span><span>)&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[</span><span class="word">i</span><span>],&nbsp;</span><span class="word">array</span><span>[</span><span class="word">right</span><span>]);&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;不加if也可以</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;then&nbsp;conquer</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">quick_sort</span><span>(</span><span class="word">array</span><span>,&nbsp;</span><span class="word">left</span><span>,&nbsp;</span><span class="word">i</span><span>-</span><span class="value">1</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">quick_sort</span><span>(</span><span class="word">array</span><span>,&nbsp;</span><span class="word">i</span><span>+</span><span class="value">1</span><span>,&nbsp;</span><span class="word">right</span><span>);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;no&nbsp;need&nbsp;to&nbsp;combine&nbsp;sub-solutions</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li></ol></div>
<div class="sh"><div class="bar">stackless quicksort（數字為正數）</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">quick_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">left</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">right</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[</span><span class="word">N</span><span>]&nbsp;=&nbsp;-</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">i</span><span>]&nbsp;&gt;&nbsp;</span><span class="value">0</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">pivot</span><span>&nbsp;=&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>],&nbsp;</span><span class="word">k</span><span>&nbsp;=&nbsp;</span><span class="word">i</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="word">i</span><span>+</span><span class="value">1</span><span>;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]&nbsp;&lt;&nbsp;</span><span class="value">0</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">j</span><span>]&nbsp;&lt;&nbsp;</span><span class="word">pivot</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[++</span><span class="word">k</span><span>],&nbsp;</span><span class="word">array</span><span>[</span><span class="word">j</span><span>])</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">swap</span><span>(</span><span class="word">array</span><span>[</span><span class="word">i</span><span>],&nbsp;</span><span class="word">array</span><span>[</span><span class="word">k</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">k</span><span>]&nbsp;=&nbsp;-</span><span class="word">array</span><span>[</span><span class="word">k</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>]&nbsp;=&nbsp;-</span><span class="word">array</span><span>[</span><span class="word">i</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li></ol></div>
<div class="sh"><div class="bar">stackless quicksort</div><ol><li><span class="word">https</span><span>:</span><span class="comment">//github.com/yuhanlyu/Snippets/blob/master/sort/quickstackless.c</span></li></ol></div>
<p>Quicksort 演算法的陷阱相當多，須考慮數字全都相等、判斷式是小於還是小於等於、分割點恰好選到最大值或者最小值、遞迴的區段範圍、遞迴的區段很短、 …… 等等問題。編寫 Quicksort 的程式碼時，最好是寫一支窮舉所有排列的程式，一一排序、一一驗證。如果擔心自己寫的程式碼用在正事上不妥當，也可以採用程式語言函式庫內建的 Quicksort 。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/7/755.html">755</a></p>
<p class="t">© 2010  <a href="http://tkcnandy.blogspot.com/"> tkcn </a> . All rights reserved.</p>
<script src="./Sequence Manipulation_files/Quicksort.js.下载"></script><script defer="defer">quicksort.onInjectionDone('quicksort')</script>
<p class="d" id="Quicksort"><div class="G15jkyanO" style="overflow: auto; position: relative; zoom: 1;"><div style="position: relative; zoom: 1;"><div><div style="margin-bottom:5px;"> <input type="text" tabindex="0" class="G15jkyanGB">ms <button type="button" tabindex="0" class="gwt-Button">Play</button> <button type="button" tabindex="0" class="gwt-Button" disabled="">Stop</button> <button type="button" tabindex="0" class="gwt-Button">Next</button> <button type="button" tabindex="0" class="gwt-Button">Reset</button> </div> <div class="G15jkyanFB" style="overflow: auto; position: relative; zoom: 1;"><div style="position: relative; zoom: 1;"></div><ul></ul></div> <div class="G15jkyanAB" style="overflow: auto; position: relative; zoom: 1;"><div style="position: relative; zoom: 1;"><div class="G15jkyanJ" style="position: relative; overflow: hidden; height: 95px;"><div class="gwt-Label" style="position: absolute; left: 47px; top: 10px;">0</div><div class="gwt-Label" style="position: absolute; left: 75px; top: 10px;">1</div><div class="gwt-Label" style="position: absolute; left: 103px; top: 10px;">2</div><div class="gwt-Label" style="position: absolute; left: 131px; top: 10px;">3</div><div class="gwt-Label" style="position: absolute; left: 159px; top: 10px;">4</div><div class="gwt-Label" style="position: absolute; left: 187px; top: 10px;">5</div><div class="gwt-Label" style="position: absolute; left: 215px; top: 10px;">6</div><div class="gwt-Label" style="position: absolute; left: 243px; top: 10px;">7</div><div class="gwt-Label" style="position: absolute; left: 271px; top: 10px;">8</div><div class="gwt-Label" style="position: absolute; left: 299px; top: 10px;">9</div><table class="G15jkyanCB" cellspacing="0" style="position: absolute; left: 35px; top: 50px;"><colgroup><col></colgroup><tbody><tr><td class="G15jkyanDB G15jkyanEB">2</td><td class="G15jkyanDB">71</td><td class="G15jkyanDB">37</td><td class="G15jkyanDB">66</td><td class="G15jkyanDB">33</td><td class="G15jkyanDB">31</td><td class="G15jkyanDB">5</td><td class="G15jkyanDB">50</td><td class="G15jkyanDB">92</td><td class="G15jkyanDB">53</td></tr></tbody></table></div></div></div></div></div></div></p>
<p class="t">Heapsort</p>
<p>陣列可以做為二元樹資料結構。把陣列本身當作是 heap ，逐一把數字加入 heap ，達到排序功效。</p>
<p class="t">Introsort</p>
<p>Quicksort 的加強版。遞迴分割陣列，區間越來越短，數字也幾乎排序好了。對於幾乎已經排序好的區間， Quicksort 效率非常差，所以改用 Heapsort 。</p>
<p>分水嶺通常設定成 logN² = 2logN ， N 是陣列長度。</p>
<p>可以直接使用 STL 的 sort() 。</p>
<p class="t">Counting Sort</p>
<p>全部數字依其數值大小，放到相符位置。接著由小到大讀取各個位置的數字。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">counting_sort</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;歸類並標記</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">count</span><span>[</span><span class="value">10000</span><span>]&nbsp;=&nbsp;{</span><span class="value">0</span><span>};</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">count</span><span>[&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>]&nbsp;]++;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;計數陣列的索引值大小順序，正是元素大小順序。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>,&nbsp;</span><span class="word">k</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">k</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">count</span><span>[</span><span class="word">i</span><span>]--)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">k</span><span>++]&nbsp;=&nbsp;</span><span class="word">i</span><span>;</span></li><li><span>}</span></li></ol></div>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">struct</span><span>&nbsp;</span><span class="word">Data</span><span>&nbsp;{</span><span class="type">int</span><span>&nbsp;</span><span class="word">key</span><span>,&nbsp;</span><span class="word">data</span><span>;};</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">counting_sort</span><span>(</span><span class="word">Data</span><span>*&nbsp;</span><span class="word">array</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">N</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;歸類並標記</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">vector</span><span>&lt;</span><span class="word">Data</span><span>*&gt;&nbsp;</span><span class="word">count</span><span>[</span><span class="value">10000</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">count</span><span>[&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>]-&gt;</span><span class="word">key</span><span>&nbsp;].</span><span class="word">push_back</span><span>(&nbsp;</span><span class="word">array</span><span>[</span><span class="word">i</span><span>]&nbsp;);</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;索引值的大小順序，剛好也是元素的大小順序。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>,&nbsp;</span><span class="word">k</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">k</span><span>&lt;</span><span class="word">N</span><span>;&nbsp;++</span><span class="word">i</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">j</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">j</span><span>&lt;</span><span class="word">count</span><span>[</span><span class="word">i</span><span>].</span><span class="word">size</span><span>();&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">array</span><span>[</span><span class="word">k</span><span>++]&nbsp;=&nbsp;</span><span class="word">count</span><span>[</span><span class="word">i</span><span>][</span><span class="word">j</span><span>];</span></li><li><span>}</span></li></ol></div>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/4/484.html">484</a> <a href="http://uva.onlinejudge.org/external/114/11462.html">11462</a></p>
<p class="t">Bucket Sort</p>
<p>全部數字依其數值區間，放到相符桶子。接著各個桶子各自排序之後，再由小到大讀取各個桶子的數字。</p>
<p class="t">Radix Sort</p>
<p>由低位數到高位數，每個位數依序做為鍵值，做 D 次 counting sort ， D 為位數大小。</p>
<p>資料是數字，數字表示成二進位， D = logR 。</p>
<p class="t">Flash Sort</p>
<p><a href="http://www.cnblogs.com/kkun/archive/2011/11/24/2261529.html"> http://www.cnblogs.com/kkun/archive/2011/11/24/2261529.html </a></p>
<p class="t">延伸閱讀：以指標排序</p>
<p>排序會搬動資料，但是大多數時候我們不希望搬動資料。此時可以取出資料的記憶體位址，存入指標，對指標進行排序。</p>
<p>也有人以索引值排序，道理跟指標相同。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/4/482.html">482</a></p>
<p class="t">延伸閱讀： stable</p>
<p>兩筆相同資料，原本排在前頭的，排序後仍在前頭；原本排在後頭的，排序後仍在後頭。這稱作 stable 的排序演算法，相同資料、順序不變。</p>
<p>只要是放在陣列的資料，任何一種排序演算法，都可以擴充成 stable 的排序演算法。你想到解決方法了嗎？</p>
<p class="t">延伸閱讀： lexicographical order</p>
<p>當資料是高維度數據，如何比較大小呢？其中一種方式叫做字典順序，先比較第一維度；如果平手，再比較第二維度；如果又平手，再比較第三維度；以此類推。</p>
<p>英文字典，即採用了字典順序，排序所有英文單字。英文字典當中，兩個英文單字比較大小的方式，就是字典順序。</p>
<p class="t">延伸閱讀： Sorting Network</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/11/1117.html">1117</a></p>

</div></div><div class="a" id="2"><div class="h">
<p class="b">Search</p>
<p class="w">眾裏尋他千百度，驀然回首，那人卻在，燈火闌珊處。《辛棄疾．青玉案》</p>
</div><div class="c">
<p class="t">Search</p>
<p>搜尋。在資料結構當中，找出一個東西的位置。</p>
<p>常與 Search 相提並論的有 Sort ：在資料結構當中，把所有東西排好順序，放在正確位置。另外還有 Select ：在資料結構當中，找到特定順位的資料。</p>
<p>資料結構千變萬化，各有其獨特的 Search 、 Sort 、 Select 演算法。在陣列中，便有 Binary Search 、 Bubble Sort 、 Quickselect 這些演算法；在圖論中，則有 Depth-first Search 這樣的演算法。</p>
<p>甚至也有專為 Search 、 Sort 、 Select 而設計的資料結構，如各種 Priority Queue 、各種 Search Tree 、 Hash Table 、 …… 等等。</p>
<p class="t">Search in Array: Sequential Search</p>
<p>循序搜尋。依序看一遍，無一遺漏。時間複雜度是 O(N) 。</p>
<p class="t">Search in Sorted Array: Binary Search</p>
<p>二元搜尋。相信各位耳熟能詳。這裡只作重點歸納。</p>
<p>Binary Search 的功用，是在一個排序過的數列（遞增數列、遞減數列）當中，找出某個數字的索引值（ index ）。</p>
<p>基本原理是 Divide and Conquer 。當資料存放在陣列 ──Binary Search 是將一個將排序好的陣列，分為大的一邊和小的一邊，再看看我們要找的元素會在哪一邊。如此下去直到找到為止。分割的時候，也是採用對半分，時間複雜度是 O(logN) ，以 2 為底的 logN 。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">binary_search</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">left</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">right</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">pivot</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">left</span><span>&nbsp;&lt;=&nbsp;</span><span class="word">right</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">mid</span><span>&nbsp;=&nbsp;(</span><span class="word">left</span><span>&nbsp;+&nbsp;</span><span class="word">right</span><span>)&nbsp;/&nbsp;</span><span class="value">2</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">mid</span><span>]&nbsp;&lt;&nbsp;</span><span class="word">pivot</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">left</span><span>&nbsp;=&nbsp;</span><span class="word">mid</span><span>&nbsp;+&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">mid</span><span>]&nbsp;&gt;&nbsp;</span><span class="word">pivot</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">right</span><span>&nbsp;=&nbsp;</span><span class="word">mid</span><span>&nbsp;-&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">array</span><span>[</span><span class="word">mid</span><span>]&nbsp;==&nbsp;</span><span class="word">pivot</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">mid</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">left</span><span>;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;如果找不到，就回傳稍大一點的數值位置。</span></li><li><span>}</span></li></ol></div>
<p>我想大家最好自己重新寫一份，並且驗證它在任何情形下，結果都是正確無誤的，而不會有超出陣列範圍的結果。另外也請看看這篇文章：<a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html" class="l"> Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken </a>。</p>
<p>上面這支程式亦可改用遞迴寫出來，不妨試試。</p>
<p>資料往往都是排序整齊的，也因此， Binary Search 常被用來加速程式。一旦看到數據資料有排序、遞增遞減、成正比反比的時候，便要想到 Binary Search 。</p>
<p>還有一種常見的應用是：資料恰有兩種性質，明顯地分做兩邊 ── 想找到分界之處，便可以用 Binary Search 。</p>
<p>很多問題其實都隱含著上述這種性質，只是不容易發現。嘗試從問題當中發掘這種性質，並且寫程式解決問題，這便是程式設計深奧且有趣之處。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/106/10611.html">10611</a> <a href="http://uva.onlinejudge.org/external/100/10077.html">10077</a></p>
<p class="t">Search in Sorted Array</p>
<p>「<a href="http://knowledge.x-family.asia/modules/tad_book3/page.php?tbdsn=503"> Interpolation Search </a>」、「<a href="http://knowledge.x-family.asia/modules/tad_book3/page.php?tbdsn=504"> Fibonacci Search </a>」。雞肋。</p>
<p class="t">Search in Sorted Unbound Array: Doubling Search</p>
<p>倍增搜尋。主持人心中有一正整數，我們可以一直猜他心中的正整數，但是他只會回答「太高」或「太低」或「正確」。請問要怎麼猜可以最快猜到他心中的正整數呢？</p>
<p>有個類似的團康遊戲叫做「終極密碼」，常常在綜藝節目出現。「終極密碼」的規則比較不一樣，數字範圍通常只有 1 到 100 ，而且是很多個人輪流猜，越晚猜出來越好。這裡的猜數字遊戲，數字範圍是 1 到無限大，只有一個人猜，越早猜出來越好。</p>
<p>言歸正傳。從 1 開始一個一個往上猜，實在太慢了。比較快的猜法，是將問題分成兩個步驟，第一個步驟是先確定範圍，第二個步驟再來縮小範圍。</p>
<p>確定範圍：可以從 1 、 2 、 4 、 8 、 …… 這個順序去猜。如果主持人不斷回答太低，我們就不斷往大數字猜，一直到主持人回答太高為止。如果主持人心中的正整數為 N ，則可以用 O(logN) 的時間得到一個合理的範圍， N 會落在 (2ᵏ⁻¹, 2ᵏ] 之間。</p>
<p>縮小範圍：可以使用 Binary Search ！從 (2ᵏ⁻¹, 2ᵏ] 之間找出正確的正整數，只需 O(logN) 時間。</p>
<p>二分搜尋和倍增搜尋相互對立，前者除以二、後者乘以二。</p>
<p class="t">Search in Sorted Arrays: Fractional Cascading</p>
<p><a href="http://en.wikipedia.org/wiki/Fractional_cascading"> http://en.wikipedia.org/wiki/Fractional_cascading </a></p>
<p class="t">Search in Sorted Matrix: Saddleback Search</p>
<p>一個排序過的陣列可以用 Binary Search 來搜尋數字，那麼一個排序過的二維矩陣呢？當一個二維矩陣裡的元素經過排序，任一位置往右、往下都呈現嚴格遞增時（嚴格遞減也行），此時有個很巧妙的搜尋方式，時間複雜度為 O(X+Y) ， X 與 Y 分別為矩陣的長與寬。</p>
<img src="./Sequence Manipulation_files/Search1.png">
<p>首先在腦中將矩陣的元素切割為大於 n 的一邊（右下角）與不大於 n 的一邊（左下角）。現在我們所要作的，便是遊走於大與小的邊緣來尋找 n ！從矩陣的右上角開始，嘗試走到左下角，若走到了大於 n 的一邊，就立即往不大於 n 的另一邊移動，反之亦同。</p>
<p>各位可以想想當找到目標元素時，應該往左還是往下走好？當矩陣元素是非嚴格遞增的時候會產生什麼問題？</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/121/12192.html">12192</a></p>
<p class="t">Search in Sorted Matrix: 2D Binary Search</p>
<p>只有特殊情況能派上用場。</p>
<p>一個排序過的陣列可以用 Binary Search 來搜尋數字，那麼一個排序過的二維矩陣呢？</p>
<p>搜尋已排序陣列，都是切對半、從中位數切成兩半。搜尋已排序矩陣，亦可如法炮製，從中位數們的中位數（中中數）切成兩半。</p>
<p>矩陣切成一條一條陣列，找到中中數；實施 Saddleback Search ，以中中數將矩陣分為大的一邊和小的一邊，遞迴找其中一邊。</p>
<img src="./Sequence Manipulation_files/Search2.png">
<p>時間複雜度分析：</p>
<p>一、每一條陣列（已排序），各自找到中位數，總共 O(Y) 。</p>
<p>二、中位數們（未排序），找到中位數，使用後面章節的演算法， O(X) 。</p>
<p>三、 Saddleback Search ， O(X+Y) 。</p>
<p>四、小於等於中中數的數字們，至少佔 1/4 。大於等於亦如是。遞迴找其中一邊，至少刪 1/4 、至多剩 3/4 。總共 O(logXY) 回合。</p>
<img src="./Sequence Manipulation_files/Search3.png">
<p>每回合的時間複雜度為 O(X+Y) ，總共 O(logXY) 回合，總時間複雜度為 O((X+Y)logXY) 。</p>
<p>時間複雜度難以記憶。簡易的方式，是把 X 和 Y 視作相等，等於 N 。每回合需時 O(N) ，總共 O(logN²) = O(2logN) = O(logN) 回合，總時間複雜度為 O(NlogN) 。</p>
<p>此演算法沒有實務上的價值，只有理論上的價值，而且只有特殊情況能派上用場：資料恰有兩種性質，明顯地分做兩邊 ── 想找到分界之處。 Saddleback Search 每一步都要判斷在哪一邊，總共判斷 O(N) 次。 2D Binary Search 每一回合只需判斷中中數在哪一邊，總共判斷 O(logN) 次。</p>

</div></div><div class="a" id="3"><div class="h">
<p class="b">Select</p>
<p class="w">羽望見良麾蓋，策馬刺良於萬眾之中，斬其首還。《三國志》</p>
</div><div class="c">
<p class="t">Select</p>
<p>選擇。找到特定名次的數字，例如第 k 小、第 k 大的數字。或者，找到特定數字的名次。</p>
<p>最簡單的方式就是先排序、再搜尋。以下我們探討更快的方法。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/100/10041.html">10041</a> <a href="http://uva.onlinejudge.org/external/101/10107.html">10107</a> <a href="http://uva.onlinejudge.org/external/118/11875.html">11875</a></p>
<p class="t">Select in Array: Quickselect</p>
<p>Quicksort 只遞迴其中一邊。最佳、平均時間複雜度為 O(N) ，最差是 O(N²) 。</p>
<p class="t">Select in Array: Median-of-Medians Algorithm</p>
<p>找到中位數們的中位數，將數字分成大的一邊和小的一邊，遞迴找其中一邊。時間複雜度 O(N) ，但是不實用。</p>
<pre>1. 五個五個分堆，最後一堆可以沒有滿。

   第一堆 ● ● ● ● ●
   第二堆 ● ● ● ● ●
   第三堆 ● ● ● ● ●
   第四堆 ● ● ● ● ●
   第五堆 ● ● ● ● ●
   第六堆 ● ● ●

2. 每堆各自排序。然後求出每堆的中位數 ○。

      小  →  大
   ↑  ● ● ○ ● ●
   沒 ● ● ○ ● ●
   有 ● ● ○ ● ●
   順 ● ● ○ ● ●
   序 ● ● ○ ● ●
   ↓    ● ○ ●     ← 最後一堆對齊一下比較好看

3. 求出中位數們的中位數 x。遞迴套用此演算法求得 x。

      小  →  大
   ↑  ● ● ○ ● ●
   沒 ● ● ○ ● ●
   有 ● ● ○ ● ●
   順 ● ● ○ ● ●
   序 ● ● x ● ●   ← 中位數可能在任何一個地方
   ↓    ● ○ ●

4. 將全部的數字分成兩邊，一邊小於 x ，一邊大於等於 x。

         小於 x ←|   |→ 大於等於 x
   ... ● ● ● ● ● ● x ● ● ● ● ● ● ● ● ...

5. 看看 k 是在哪一邊。遞迴下去找出答案。
</pre>
<pre>時間複雜度証明

          小  →  大
   第一堆 ● ● ○ ● ●
   第二堆 ● ● ○ ● ●
   第三堆 ● ● ○ ● ●
   第四堆 ● ● ○ ● ●
   第五堆 ● ● x ● ●
   第六堆   ● ○ ●

依照中位數們的大小，重新排列每一堆。

              小  →  大
   第四堆  中 ● ● ○ ● ●
   第二堆  位 ● ● ○ ● ●
   第五堆  數 ● ● x ● ●   ← 中位數 x 變成排在中間
   第一堆  小 ● ● ○ ● ●
   第三堆  ↓  ● ● ○ ● ●
   第六堆  大   ● ○ ●

觀察一定小於等於x的數、一定大於等於x的數。

   一定小於    一定大於
   等於x的數   等於x的數
   ◊ ◊ ◊ ● ●   ● ● ○ ● ●
   ◊ ◊ ◊ ● ●   ● ● ○ ● ●
   ◊ ◊ x ● ●   ● ● x ◊ ◊
   ● ● ○ ● ●   ● ● ◊ ◊ ◊
   ● ● ○ ● ●   ● ● ◊ ◊ ◊
     ● ○ ●       ● ◊ ◊

推得「小於等於 x 的數至少有 3n/10 - 6 個。大於 x 的數至多有 7n/10 + 6 個。」
推得「大於等於 x 的數至少有 3n/10 - 6 個。小於 x 的數至多有 7n/10 + 6 個。」

  至多7n/10 + 6         差不多至多7n/10 + 6
         小於 x ←|   |→ 大於等於 x
   ... ● ● ● ● ● ● x ● ● ● ● ● ● ● ● ...

分兩邊後，
小於的那一邊至多有 7n/10 + 6 個，
大於等於的那一邊差不多至多有 7n/10 + 6 個。
遞迴下去，總時間複雜度為 O(n)。
</pre>
<p>可以直接使用 STL 的 nth_element() 。</p>
<p class="t">Select in Sorted Array</p>
<p>O(1) 。</p>
<p class="t">Select in Sorted Arrays</p>
<p>找到中位數們的中位數，每列皆實施 Binary Search ，最後所有數字分為大的一邊和小的一邊，遞迴找其中一邊。兩邊的數量至少都是一半的列的一半，每回合至少削減一半的列的一半。每列各自建立首尾索引值，記錄剩下的元素。</p>
<p>每回合需時 O(XlogY) ，總共 O(logY) 回合，時間複雜度為 O(XlogYlogY) 。其中 X 是陣列數量， Y 是陣列長度。</p>
<p>簡單來說，此演算法是搜尋中中數、分兩邊、遞迴一邊。</p>
<p class="t">Select in Sorted Arrays</p>
<p>找到中位數們的中位數，找到最大中位數、最小中位數。最小中位數至少小於一半的數字，最大中位數亦如是。判斷第 K 大是小於一半或大於一半，每回合削減最大中位數的右半或最小中位數的左半。每次刪除一列的一半，總共 O(XlogY) 回合。</p>
<p>以大小為 X 的二元搜尋樹儲存中位數，每回合可以快速找到最大與最小中位數。一共操作 O(XlogY) 次，每次操作 O(logX) ，時間複雜度為 O(XlogXlogY) 。其中 X 是陣列數量， Y 是陣列長度。</p>
<p class="t">Select in Sorted Matrix</p>
<p>切成一列一列，找到中位數們的中位數，再利用 Saddleback Search 將矩陣分為大的一邊和小的一邊，遞迴找其中一邊。</p>
<p>每回合需時 O(N) ，總共 O(logN) 回合，時間複雜度為 O(NlogN) 。</p>
<p class="t">Select in Sorted Matrix</p>
<p><a href="http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf"> http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf </a></p>
<p>Divide and Conquer 。 O(N) 。</p>

</div></div><div class="a" id="4"><div class="h">
<p class="b">Count</p>
<p class="w">選出牡丹第一枝，勸君折取莫遲疑，世間若問相知處，萬事逢春正及時。《六十甲子籤》</p>
</div><div class="c">
<p class="t">Longest Plateau</p>
<p>一條數列，找到連續出現最多次的數字暨次數。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">longest_plateau</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">a</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">n</span><span>&nbsp;==&nbsp;</span><span class="value">0</span><span>)&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="value">0</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">counter</span><span>&nbsp;=&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">length</span><span>&nbsp;=&nbsp;</span><span class="value">1</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">1</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">n</span><span>;&nbsp;</span><span class="word">i</span><span>++)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>[</span><span class="word">i</span><span>]&nbsp;==&nbsp;</span><span class="word">a</span><span>[</span><span class="word">i</span><span>-</span><span class="value">1</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">counter</span><span>++;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">length</span><span>&nbsp;=&nbsp;</span><span class="word">max</span><span>(</span><span class="word">length</span><span>,&nbsp;</span><span class="word">counter</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">counter</span><span>&nbsp;=&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">length</span><span>;</span></li><li><span>}</span></li></ol></div>
<p>已排序數列，有更簡單的做法。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">longest_plateau</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">a</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">n</span><span>&nbsp;==&nbsp;</span><span class="value">0</span><span>)&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="value">0</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">length</span><span>&nbsp;=&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;</span><span class="value">1</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">n</span><span>;&nbsp;</span><span class="word">i</span><span>++)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>[</span><span class="word">i</span><span>]&nbsp;==&nbsp;</span><span class="word">a</span><span>[</span><span class="word">i</span><span>-</span><span class="word">length</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">length</span><span>++;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">length</span><span>;</span></li><li><span>}</span></li></ol></div>
<p class="t">Mode</p>
<p>一條數列，找到出現最多次的數字暨次數。</p>
<p>先排序再搜尋。採用交換式排序，例如 quicksort 或者 merge sort ，時間複雜度 O(NlogN) ，額外的空間複雜度 O(1) 。採用索引式排序，例如 counting sort 或者 hash table ，時間複雜度 O(N+R) ，額外的空間複雜度 O(R) 。</p>
<p class="t">Majority Vote</p>
<p>一條數列，找到出現過半的數字暨次數。時間複雜度 O(N) ，額外的空間複雜度 O(1) 。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="type">int</span><span>&nbsp;</span><span class="word">find_mode</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">a</span><span>[],&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">n</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">mode</span><span>&nbsp;=&nbsp;</span><span class="word">a</span><span>[</span><span class="value">0</span><span>],&nbsp;</span><span class="word">counter</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">n</span><span>;&nbsp;</span><span class="word">i</span><span>++)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">counter</span><span>&nbsp;==&nbsp;</span><span class="value">0</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">mode</span><span>&nbsp;=&nbsp;</span><span class="word">i</span><span>,&nbsp;</span><span class="word">counter</span><span>&nbsp;=&nbsp;</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>[</span><span class="word">i</span><span>]&nbsp;==&nbsp;</span><span class="word">mode</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">counter</span><span>++;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">counter</span><span>--;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">counter</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>=</span><span class="value">0</span><span>;&nbsp;</span><span class="word">i</span><span>&lt;</span><span class="word">n</span><span>;&nbsp;</span><span class="word">i</span><span>++)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>[</span><span class="word">i</span><span>]&nbsp;==&nbsp;</span><span class="word">mode</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">counter</span><span>++;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">counter</span><span>&nbsp;&lt;&nbsp;(</span><span class="word">n</span><span>+</span><span class="value">1</span><span>)/</span><span class="value">2</span><span>)&nbsp;</span><span class="keyword">return</span><span>&nbsp;-</span><span class="value">1</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="word">counter</span><span>;</span></li><li><span>}</span></li></ol></div>
<p class="t">Maximum Gap</p>
<p>給定一串未排序數列，排序之後，考慮相鄰兩數的差值，其中最大的差值稱作「最大間隔」。可能同時有許多個「最大間隔」。</p>
<p>時間複雜度 O(N) ，不必排序，就能找出所有最大間隔。但是前提是 floor 運算是 O(1) 。</p>
<pre>一、找到最大值max、最小值min。
二、建立N-1個bucket，
　　一個bucket的範圍大小是 D = (max-min)/(N-1)。
三、除了最大值、最小值以外，
　　剩下的N-2個數字通通塞入bucket，
　　數字 x 塞到 floor[(x-min)/D]。
回、N-1個bucket，N-2個數字，必有空的bucket。
　　所以最大間隔的兩數必定跨過空的bucket，最大間隔大於D。
　　換句話說，最大間隔的兩數不在同一個bucket。
四、刪除空的bucket，重新編號。
　　算出各個bucket內含數字的最大值bucket[i].max、最小值bucket[i].min。
五、max { bucket[i+1].min - bucket[i].max } 即是最大間隔。
</pre>
<p class="t">Minimum Gap</p>
<p>一串數列當中，找到相差最小的兩個數字。</p>
<p>給定一串未排序數列，排序之後，考慮相鄰兩數的差值，其中最小的差值稱作「最小間隔」。一條數列可能同時有許多個「最小間隔」。</p>
<p>時間複雜度 O(NlogN) 。</p>
<p>【待補文字】</p>
<p class="t">Count Distinct</p>
<p>一串數列當中，找到相異數字個數。</p>
<p>http://ravi-bhide.blogspot.tw/2011/04/flajolet-martin-algorithm.html</p>
<p>https://chenjiehua.me/database/hyperloglog-bigdata.html</p>
<pre>末一位可能是0/1，如果都出現，答案至少2
末二位可能是00/01/10/11，如果都出現，答案至少4
</pre>
<p>【待補文字】</p>

</div></div><div class="a" id="5"><div class="h">
<p class="b">Pairwise Sum</p>
</div><div class="c">
<p class="t">X+Y</p>
<p>窮舉法。 O(N²) 。</p>
<p>Fourier Transform 。 O(N + RlogR) 。</p>
<p class="t">Sort in X+Y</p>
<p>先窮舉，再排序。 O(N²logN²) = O(N²logN) 。</p>
<p>先排序， N-way Merge 。 O(N²logN) 。</p>
<p>Fourier Transform 。 O(N + RlogR) 。</p>
<p class="t">Search in X+Y</p>
<p>先排序。想像矩陣 add[i][j] = a[i] + b[j] ，已排序矩陣的搜尋。 O(NlogN) 。</p>
<p class="t">Select in X+Y</p>
<p>先排序。想像矩陣 add[i][j] = a[i] + b[j] ，已排序矩陣的選擇。 O(NlogN) 。</p>
<p class="t">Search in 2D X+Y</p>
<p><a href="http://arxiv.org/abs/0809.1171"> http://arxiv.org/abs/0809.1171 </a></p>
<p>找 y/x 。最差 O(NlogNlogN) ，平均 Θ(NlogN) 。</p>
<p class="t">Select in 2D X+Y</p>
<p><a href="http://arxiv.org/abs/0809.1171"> http://arxiv.org/abs/0809.1171 </a></p>
<p>找 y/x 。 Θ(NlogN) 。</p>
<p class="t">Extremum in 2D X+Y</p>
<p>找 y/x 。必在凸包上。 Θ(NlogN) 。</p>

</div></div><div class="a" id="6"><div class="h">
<p class="b">Pairwise Distance</p>
</div><div class="c">
<p class="t">All Row Minimums</p>
<p>以下介紹三個特殊矩陣，以及其「每一個橫條（直條）的最小值」的演算法。</p>
<p>Monge Matrix ⇒ Totally Monotone Matrix ⇒ Monotone Matrix 。從特例到通例，限制從強到弱，數量從少到多，演算法從快到慢。</p>
<pre>Monge Matrix (concave)
[standard form] ↖ + ↘ ≤ ↗ + ↙      主對角線和，小於等於次對角線和
     [row form] ↘ - ↙ ≤ ↗ - ↖      橫條各處斜率，往上遞增
  [column form] ↘ - ↗ ≤ ↙ - ↖      直條各處斜率，往左遞增

Totally Monotone Matrix
   [row type] if ↙ ≤ ↘ then ↖ ≤ ↗  橫條小於等於關係，往上遞增
[column type] if ↗ ≤ ↘ then ↖ ≤ ↙  直條小於等於關係，往左遞增

Monotone Matrix
   [row type] argmin ⤷             橫條最小值位置，往下遞增
[column type] argmin ⤵             直條最小值位置，往右遞增
</pre>
<p class="t">Monge Matrix</p>
<p>矩陣當中所有田字四個格子皆滿足不等式： ↖ + ↘ ≤ ↗ + ↙ 。</p>
<p>不等式分成凹凸兩種，大小相反、性質顛倒。以下以凹為主。</p>
<pre>Concave Monge Matrix: a[i][j] + a[i+1][j+1] ≤ a[i][j+1] + a[i+1][j]
 Convex Monge Matrix: a[i][j] + a[i+1][j+1] ≥ a[i][j+1] + a[i+1][j]
</pre>
<img src="./Sequence Manipulation_files/MongeMatrix1.png">
<p>另一種等價的寫法：所有子矩形的四個端點皆滿足不等式。</p>
<pre>a[i₁][j₁] + a[i₂][j₂] ≤ a[i₁][j₂] + a[i₂][j₁] when i₁ &lt; i₂ and j₁ &lt; j₂
</pre>
<img src="./Sequence Manipulation_files/MongeMatrix2.png">
<p>移項一下，得到橫條（直條）斜率遞減的形式。彷彿凹函數。</p>
<img src="./Sequence Manipulation_files/MongeMatrix3.png">
<p>Monge Matrix 乘以非負倍率，仍是 Monge Matrix 。 Monge Matrix 相加，仍是 Monge Matrix 。</p>
<pre>Monge Matrix has "non-negative linearity":
(1) X is Monge Matrix, k ≥ 0   ⇒ kX is Monge Matrix
(2) X and Y are Monge Matrices ⇒ X+Y is Monge Matrix
</pre>
<img src="./Sequence Manipulation_files/MongeMatrix4.png">
<p>Monge Matrix 刪除任意橫條（直條），仍是 Monge Matrix 。 Monge Matrix 的其中一個橫條（直條），一齊加上同一個非負數，仍是 Monge Matrix 。</p>
<img src="./Sequence Manipulation_files/MongeMatrix5.png">
<p>Symmetric Monge Matrix = Supnick Matrix 。恰好沿著主對角線對稱。矩陣行列索引值，可以自由對調。</p>
<img src="./Sequence Manipulation_files/MongeMatrix6.png">
<p>Convex/Concave Monge Matrix = Submodular/Supermodular Function 。矩陣行列索引值，視作區間左右邊界。</p>
<img src="./Sequence Manipulation_files/MongeMatrix7.png">
<p>舉個實際範例。例如二維平面上，凸四邊形上下邊相加  ≤  兩條對角線相加，距離雙向均等，符合 Supnick Matrix 不等式。</p>
<img src="./Sequence Manipulation_files/MongeMatrix8.png">
<p>Supnick Matrix 的延伸意義是：不交換最好。尋找最佳排列的問題，例如 Travelling Salesman Problem 、 Bipartite Matching ，若滿足 Supnick Matrix ，則有快速演算法。</p>
<p class="t">Totally Monotone Matrix</p>
<p>分成凹凸兩種，又細分成橫直兩種，共四種。以下以凹為主。</p>
<p>橫條往左（直條往上）， &lt; 與 = 的總數量遞增。只會增加或不變、不會減少。</p>
<pre>concave row version:    if ↙ ≤ ↘ then ↖ ≤ ↗
concave column version: if ↗ ≤ ↘ then ↖ ≤ ↙
</pre>
<p>還有另一種更嚴格的定義： ≤ 的數量遞增。</p>
<pre>concave row version:    (if ↙ &lt; ↘ then ↖ &lt; ↗) and
                        (if ↙ = ↘ then ↖ ≤ ↗)
concave column version: (if ↗ &lt; ↘ then ↖ &lt; ↙) and
                        (if ↗ = ↘ then ↖ ≤ ↙)
</pre>
<img src="./Sequence Manipulation_files/MonotoneMatrix1.png">
<p>自然界難以見到 Totally Monotone Matrix ，其定義是計算學家故意設計的，是從 Monge Matrix 的不等式所推導出來的性質。</p>
<p>Monge Matrix ⇒ Totally Monotone Matrix 的證明：橫條（直條）斜率遞減的形式當中，若左式非負，則右式也非負。</p>
<p class="t">Monotone Matrix</p>
<p>分成凹凸兩種，又細分成橫直兩種，共四種。以下以凹為主。</p>
<p>橫條往右（直條往下），每個橫條（直條）的第一個最小值位置遞增。最小值可能有許多個，所謂的第一個是指索引值最小者。</p>
<pre>row version:    argmin r₀ ≤ argmin r₁ ≤ argmin r₂ ≤ ... 
column version: argmin c₀ ≤ argmin c₁ ≤ argmin c₂ ≤ ... 
</pre>
<img src="./Sequence Manipulation_files/MonotoneMatrix2.png">
<p>自然界難以見到 Monotone Matrix ，其定義是計算學家故意設計的，是從 Totally Monotone Matrix 的不等式所推導出來的性質。</p>
<p>Totally Monotone Matrix ⇒ Monotone Matrix 的證明：因為上方橫條（左方直條）小於等於關係不變，所以最小值位置只可能一樣、或者更往左（更往上）。</p>
<p class="t">尋找 Monotone Matrix 的每個橫條（直條）的第一個最小值</p>
<p>分治法。找到中央橫條的最小值，然後左上矩陣與右下矩陣，分別遞迴求解。時間複雜度 O(YlogX) 。</p>
<img src="./Sequence Manipulation_files/MonotoneMatrix3.png">
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">X</span><span>&nbsp;=&nbsp;</span><span class="value">6</span><span>;</span></li><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">Y</span><span>&nbsp;=&nbsp;</span><span class="value">8</span><span>;</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">a</span><span>[</span><span class="word">X</span><span>][</span><span class="word">Y</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;monotone&nbsp;matrix</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">min_index</span><span>[</span><span class="word">X</span><span>];&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;記錄最小值位置</span></li><li>&nbsp;</li><li><span class="comment">//&nbsp;call&nbsp;minimum(0,&nbsp;X-1,&nbsp;0,&nbsp;Y-1)&nbsp;at&nbsp;first</span></li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">minimum</span><span>(</span><span class="type">int</span><span>&nbsp;</span><span class="word">i1</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i2</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">j1</span><span>,&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">j2</span><span>)</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">i1</span><span>&nbsp;&gt;&nbsp;</span><span class="word">i2</span><span>)&nbsp;</span><span class="keyword">return</span><span>;</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comments">/*&nbsp;divide：找到中央橫條的最小值&nbsp;*/</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;(</span><span class="word">i1</span><span>&nbsp;+&nbsp;</span><span class="word">i2</span><span>)&nbsp;/&nbsp;</span><span class="value">2</span><span>,&nbsp;</span><span class="word">j</span><span>;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;中央橫條、最小值位置</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">min</span><span>&nbsp;=&nbsp;</span><span class="value">1e9</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="word">j</span><span>=</span><span class="word">j1</span><span>;&nbsp;</span><span class="word">j</span><span>&lt;=</span><span class="word">j2</span><span>;&nbsp;++</span><span class="word">j</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>[</span><span class="word">i</span><span>][</span><span class="word">j</span><span>]&nbsp;&lt;&nbsp;</span><span class="word">min</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">min</span><span>&nbsp;=&nbsp;</span><span class="word">a</span><span>[</span><span class="word">i</span><span>][</span><span class="word">j</span><span>];</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">min_index</span><span>[</span><span class="word">i</span><span>]&nbsp;=&nbsp;</span><span class="word">j</span><span>;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comments">/*&nbsp;conquer：左上矩陣與右下矩陣，分別遞迴求解。*/</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">minimum</span><span>(</span><span class="word">i1</span><span>,&nbsp;</span><span class="word">i</span><span>-</span><span class="value">1</span><span>,&nbsp;</span><span class="word">j1</span><span>,&nbsp;</span><span class="word">j</span><span>);</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">minimum</span><span>(</span><span class="word">i</span><span>+</span><span class="value">1</span><span>,&nbsp;</span><span class="word">i2</span><span>,&nbsp;</span><span class="word">j</span><span>,&nbsp;</span><span class="word">j2</span><span>);</span></li><li><span>}</span></li></ol></div>
<p class="t">尋找 Totally Monotone Matrix 的每個橫條（直條）的第一個最小值</p>
<p>限制更強了，擁有更快的演算法。分治法，三個步驟。</p>
<p>一、刪除多餘直條，將 X×Y 矩陣變成 X×X 方陣：</p>
<p>把矩陣裡面每一個橫條的第一個最小值圈出來。目標是：砍掉不含第一個最小值的直條。砍到變成方陣即可，不必趕盡殺絕。</p>
<img src="./Sequence Manipulation_files/MonotoneMatrix4.png">
<p>任意橫條上面，任取兩個元素 a[i][j₁] a[i][j₂] ，比較大小。如果 a[i][j₁] ≤ a[i][j₂] ，表示右邊元素以上，皆不含第一個最小值。如果 a[i][j₁] &gt; a[i][j₂] ，表示左邊元素以下，皆不含第一個最小值。</p>
<img src="./Sequence Manipulation_files/MonotoneMatrix5.png">
<p>沿對角線前進，與右邊元素比較大小。如果 a[i][i] ≤ a[i][i+1] ，那麼姑且繼續前進，累積無效區域，使得上三角矩陣都是無效區域。如果 a[i][i] &gt; a[i][i+1] ，那麼對角線當前元素以下是無效區域，恰好跟先前的無效區域，湊出一整個直條，得以刪除。</p>
<img src="./Sequence Manipulation_files/MonotoneMatrix6.png">
<p>二、遞迴求解，以找到偶數橫條的最小值：</p>
<p>偶數橫條合併成一個 X/2×X 矩陣，遞迴求解。</p>
<img src="./Sequence Manipulation_files/MonotoneMatrix7.png">
<p>三、內插夾擠，以找到奇數橫條的最小值：</p>
<p>把矩陣裡面每一個橫條的第一個最小值圈出來，從上往下看，第一個最小值的位置從左往右遞增。用偶數橫條的最小值位置，夾擠出奇數橫條最小值的可能位置，然後窮舉搜尋就行了。</p>
<img src="./Sequence Manipulation_files/MonotoneMatrix8.png">
<p>此演算法稱做 SMAWK Algorithm 。時間複雜度 O(X+Y) 。</p>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">X</span><span>&nbsp;=&nbsp;</span><span class="value">6</span><span>;</span></li><li><span class="keyword">const</span><span>&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">Y</span><span>&nbsp;=&nbsp;</span><span class="value">8</span><span>;</span></li><li><span class="type">int</span><span>&nbsp;</span><span class="word">a</span><span>[</span><span class="word">X</span><span>][</span><span class="word">Y</span><span>];&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;totally&nbsp;monotone&nbsp;matrix</span></li><li>&nbsp;</li><li><span class="keyword">void</span><span>&nbsp;</span><span class="word">reduce</span><span>()&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;刪除多餘直條</span></li><li><span>{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="type">int</span><span>&nbsp;</span><span class="word">i</span><span>&nbsp;=&nbsp;</span><span class="value">0</span><span>;&nbsp;&nbsp;</span><span class="comment">//&nbsp;直條編號，從0到Y-1。</span></li><li>&nbsp;</li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(</span><span class="word">a</span><span>尚未成為方陣就繼續)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;a[1:i][i+1]右上直條不含第一個最小值。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>[</span><span class="word">i</span><span>][</span><span class="word">i</span><span>]&nbsp;&lt;=&nbsp;</span><span class="word">a</span><span>[</span><span class="word">i</span><span>][</span><span class="word">i</span><span>+</span><span class="value">1</span><span>]&nbsp;&amp;&amp;&nbsp;</span><span class="word">i</span><span>+</span><span class="value">1</span><span>&nbsp;&lt;&nbsp;</span><span class="word">Y</span><span>-</span><span class="value">1</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="word">i</span><span>++;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;繼續沿對角線前進，累積無效區域</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;a[1:i][i+1]恰是矩陣最右端直條，恰是一整個無效直條。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>[</span><span class="word">i</span><span>][</span><span class="word">i</span><span>]&nbsp;&lt;=&nbsp;</span><span class="word">a</span><span>[</span><span class="word">i</span><span>][</span><span class="word">i</span><span>+</span><span class="value">1</span><span>]&nbsp;&amp;&amp;&nbsp;</span><span class="word">i</span><span>+</span><span class="value">1</span><span>&nbsp;==&nbsp;</span><span class="word">Y</span><span>-</span><span class="value">1</span><span>)</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;砍第</span><span class="word">i</span><span>+</span><span class="value">1</span><span>直條;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">i</span><span>&nbsp;&gt;&nbsp;</span><span class="value">0</span><span>)&nbsp;</span><span class="word">i</span><span>--;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;a[i:n][i]左下直條不含第一個最小值。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">a</span><span>[</span><span class="word">i</span><span>][</span><span class="word">i</span><span>]&nbsp;&gt;&nbsp;</span><span class="word">a</span><span>[</span><span class="word">i</span><span>][</span><span class="word">i</span><span>+</span><span class="value">1</span><span>])</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;砍第</span><span class="word">i</span><span>直條;&nbsp;&nbsp;</span><span class="comment">//&nbsp;恰好湊成一整個無效直條。</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="word">i</span><span>&nbsp;&gt;&nbsp;</span><span class="value">0</span><span>)&nbsp;</span><span class="word">i</span><span>--;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li><span>}</span></li></ol></div>
<div class="sh"><div class="bar">&nbsp;</div><ol><li><span class="word">https</span><span>:</span><span class="comment">//github.com/hczhu/algorithm-collection/blob/master/data-structures/SMAWK.cpp</span></li></ol></div>
<p class="t">尋找 Monge Matrix 的每個橫條（直條）的第一個最小值</p>
<p>限制更強了，理應有更簡易的演算法，但是似乎沒人研究？</p>
<p>可以直接使用上述兩個演算法。</p>
<p class="e">UVa <a href="http://uva.onlinejudge.org/external/123/12311.html">12311</a></p>
</div></div><script src="./Sequence Manipulation_files/h.js.下载"></script><div class="m" style="left: 0px;"><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/index.html">◀ Index</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/SequenceManipulation.html#1">Sort</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/SequenceManipulation.html#2">Search</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/SequenceManipulation.html#3">Select</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/SequenceManipulation.html#4">Count</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/SequenceManipulation.html#5">Pairwise Sum</a></div><div class="li"><a href="http://www.csie.ntnu.edu.tw/~u91029/SequenceManipulation.html#6">Pairwise Distance</a></div></div><iframe src="javascript:&#39;&#39;" id="quicksort" tabindex="-1" style="position: absolute; width: 0px; height: 0px; border: none;" src="./Sequence Manipulation_files/saved_resource.html"></iframe><div style="display: none;"></div></body></html>